\chapter{Uživatelská dokumentace}

Tato kapitola je věnována uživatelské dokumentaci. Uživatelská dokumentace začíná ukázkou několika
TIL-Script programů. Poté následuje návod, jak spustit překladač jazyka TIL-Script a program
přeložit. Dále dokumentace popisuje standardní i matematickou knihovnu. Součástí dokumentace je
například popis funkcí standardní i matematické knihovny. Uživatel tak může při práci s jazykem
TIL-Script konzultovat tuto dokumentaci a vyhledávat si potřebné informace. Na konci dokumentace
se nachází také ukázka implementace TIL-Script knihovny v jazyce Java, příloha práce však obsahuje
také ukázku knihovny psané v jazyce Kotlin.

\section{Ukázka TIL-Script programu}

\subsection{Hello, World!}

V rámci zachování programátorské tradice začneme ukázkou implementace programu
\textit{Hello, World!}.

Náš program nejprve začíná komentáři. Zápis komentářů je stejný jako v jazyce Haskell. Obsah
komentářů je překladačem ignorován. Komentáře následuje velmi jednoduchá Kompozice. Kompozicí
aplikujeme funkci \lstinline{Println} na argument -- objekt, který chceme vypsat. Argument
\lstinline{Println} může být
libovolného typu, zde vypisujeme textový řetězec. Funkci \lstinline{Println} a literál textového
řetězce nesmíme zapomenout trivializovat.

\begin{lstlisting}[caption={Program Hello, World! v jazyce TIL-Script}]
-- Toto je komentář
-- Následující řádek vypíše Hello, World!
['Println '"Hello, World!"].
\end{lstlisting}

\subsection{Jednoduchá aritmetika}

Nyní si ukážeme složitější Kompozice, ukázku matematických funkcí, a také přiřazení hodnoty
proměnné, abychom nemuseli stejnou kompozici zbytečně provádět vícekrát. Abychom mohli využívat
matematické funkce, nesmíme zapomenout importovat matematickou knihovnu.

\begin{lstlisting}[caption={Aritmetika v jazyce TIL-Script}]
-- Import matematické knihovny
Import "class://org.fpeterek.tilscript.math.Registrar".

-- Aplikace funkce
-- Nesmíme zapomenout, že definičním oborem logaritmu
-- jsou reálná čísla, proto musíme zapsat literál reálného čísla
-- Literály reálných čísel obsahují desetinnou tečku a alepoň jednu
-- číslici před i za desetinnou tečkou
['Log '27.0 '3.0].

-- Výsledek kompozice využijeme jako argument jiné funkce
['Log ['+ '20.0 '7.0] '3.0].

-- Předchozí výsledky jsme však zbytečně zahodili
-- Abychom mohli s výsledkem dále pracovat, uložíme jej do proměnné
-- Alternativně můžeme výsledek vypsat na výstup programu

x -> Real := ['Log ['+ '20.0 '7.0] '3.0].

-- Čísla můžeme sčítat, odčítat, násobit, dělit i porovnávat

-- Vypíše True
['Println ['= ['+ '15 '5] ['- '24 '4]]].

-- Vypíše False
['Println ['= ['* '2 '3] ['/ '42 '6]]].

-- Proměnnou můžeme provést
['Println x].

-- A využít jako argument funkce
['Println ['Cos x]].

-- Na výstup programu můžeme vypsat také konstrukci
-- Zde aplikujeme funkci Print na konstrukci, abychom ji vypsali
-- Využíváme Print, ne Println, abychom nevypsali sekvenci odřádkování
['Print '['Cos x]].

-- Oddělíme konstrukci od výsledku jejího provedení
['Print '": "].

-- A nakonec konstrukci provedeme a výsledek vypíšeme
['Println ['Cos x]].
\end{lstlisting}

\subsection{Abstrakce a tvorba funkcí}

Abstrakce je základním pravidlem jak lambda kalkulu, tak programování. Nyní si abstrakce v jazyce
TIL-Script ukážeme prakticky.

Funkci lze vytvořit provedením uzávěru, nebo pomocí speciální syntaxe pro definici pojmenované
funkce. Uzávěr je konstrukcí, proto jej můžeme využít jako podkonstrukci jiné konstrukce. Definice
pojmenované funkce konstrukcí není. Definicí pojmenované funkce přiřadíme funkci jméno. Kdykoliv
pak potřebujeme funkci zmínit, využijeme k tomu její jméno. Pojmenovanou funkci nesmíme zapomenout
trivializovat.

V ukázce si také zkusíme vytvořit trochu zajímavější funkci. V předchozí ukázce jsme chtěli vypsat
konstrukci i její výsledek. V nynější ukázce si nad tímto výpisem vytvoříme abstrakci. V ukázce
využijeme funkci \lstinline{Progn}. Funkce je podrobněji popsána v dokumentaci funkcí standardní
knihovny, viz \ref{progn-fn}. Nyní pouze uvedeme, že se jedná o syntaktický cukr
nad kombinátorem $\lambda x y . y$. Je-li alespoň jeden z argumentů \lstinline{Progn} hodnota
\lstinline{Nil}, pak je nevlastní celá kompozice, jinak funkce \lstinline{Progn} vrací svůj druhý
argument. Pokud obdrží argumentů více, parser kompozici rozepíše na vnořené aplikace binární funkce
\lstinline{Progn}.

\begin{lstlisting}[caption={Funkce a uzávěry}, language=Tilscript]
-- Funkci lze zkonstruovat provedením uzávěru
[\x: Real, y: Real -> Real ['Sqrt ['+ ['* x x] ['* y y]]]].

-- Takto zkonstruovanou funkci lze aplikovat
-- Pro přehlednost lze uzávěr a argumenty uvést na více řádcích
[[\x: Real, y: Real -> Real ['Sqrt ['+ ['* x x] ['* y y]]]]
    '3.0
    '4.0].

-- Pro zpřehlednění můžeme funkci přiřadit proměnné
hypotenuse -> (Real Real Real) :=
    [\x: Real, y: Real -> Real
        ['Sqrt ['+ ['* x x] ['* y y]]]].

-- Jelikož je hypotenuse proměnná, netrivializujeme ji
['Println [hypotenuse '3.0 '4.0]].

-- Nyní si vytvoříme funkci pro výpis konstrukce a výsledku jejího provedení
-- Funkci Progn využijeme, abychom provedli více výpisů na výstup programu
-- Proměnná cons v-konstruuje konstrukci nejprve vypíše danou konstrukci
-- Za konstrukci poté dopíšeme dvojtečku
-- Nakonec musíme využít dvojí provedení, abychom provedli konstrukci
-- konstruovanou proměnnou cons
Defn PrettyPrint(cons: Construction) -> Any1 :=
    ['Progn
        ['Print cons]
        ['Print '": "]
        ['Println ^2 cons]].

-- Nakonec stačí funkci aplikovat na konstrukci
['PrettyPrint '[hypotenuse '3.0 '4.0]].
\end{lstlisting}

V praxi se klidně může stát, že bude funkce \lstinline{PrettyPrint} aplikována na funkci,
která je $v$-nevlastní pro aktuálně zkoumanou valuaci $v$. Aplikací funkce \lstinline{Println}
na hodnotu \lstinline{Nil} dojde k výpisu \lstinline{Nil} na výstup programu, přesto bude celá
Kompozice $v$-nevlastní. Toto chování je v praxi pravděpodobně žádoucí, chtěli bychom vidět, že naše
Kompozice byla $v$-nevlastní a nezkonstruovala žádnou hodnotu. Jako cvičení si však můžeme napsat
také variaci funkce \lstinline{PrettyPrint}, jež provede zápis na výstup programu pouze pokud
obdržená konstrukce není $v$-nevlastní.

Za tímto účelem musíme vytvořit novou abstrakci nad aplikací funkce \lstinline{Progn}. Abstrakci
vytvoříme uzávěrem. Uzávěr bude konstruovat funkci, která přijímá jeden argument -- výsledek
provedení konstrukce, jež je argumentem \lstinline{PrettyPrint}. Pokud bude tato konstrukce
$v$-nevlastní, bude současně $v$-nevlastní také aplikace naší abstrakce nad \lstinline{Progn}.

\begin{lstlisting}[caption={Funkce a uzávěry}]
Defn PrettyPrint(cons: Construction) -> Any1 :=
    -- Abstrakce nad aplikací Progn
    [[\x: Any1 -> Any1
        ['Progn
            ['Print cons]
            ['Print '": "]
            ['Println x]]]
            -- Argument funkce konstruované uzávěrem
            ^2 cons].
\end{lstlisting}

\subsection{Seznamy}

Další praktický příklad se týká práce se seznamy. Předvedeme, jak idiomaticky pracovat se seznamy
(tvorba, průchod, apod.). Z příkladu poté snad vyplynou také výhody induktivní implementace
seznamů, jež se využívá ve funkcionálních programovacích jazycích.

Nejprve začneme tvorbou jednoduchého seznamu. Seznam vytvoříme aplikací funkce \lstinline{ListOf}.
Funkce \lstinline{ListOf} slouží jako syntaktický cukr, který nám zjednoduší tvorbu seznamu.

Následně si zkusíme seznam projít a odstranit z něj prvky větší nebo rovné pěti. Začneme proto
tvorbou predikátu, funkce \lstinline{LessThanFive}. Dále vytvoříme rekurzivní funkci
\lstinline{GetSmall}, která vytvoří nový seznam obsahující pouze takové prvky, které jsou menší než
pět. Funkce jako svůj argument obdrží seznam. Zde můžeme vidět využití funkce \lstinline{If}.

Je-li seznam prázdný, vrátíme jej v nezměněné podobě -- z prázdného seznamu již nemáme co
odstraňovat. Argumenty funkce \lstinline{If} jsou vyhodnocovány líně -- je vždy vyhodnocena pouze
jedna podkonstrukce. Pokud by došlo k vyhodnocení obou konstrukcí, došlo by k pokusu k přístupu
prvního prvku seznamu -- prázdný seznam ovšem nemá první prvek. Celá aplikace \lstinline{GetSmall}
by tak byla $v$-nevlastní pro všechny argumenty a ve všech valuacích (jednalo by se o funkci
\textit{degenerovanou}).

Pokud je seznam neprázdný, potřebujeme provést další aplikaci funkce \lstinline{If}. Nejprve
zkontrolujeme, jestli je první prvek seznamu menší než pět. Nezávisle na hodnotě aktuálního prvku --
pomocí funkce \lstinline{Tail} vezmeme seznam bez jeho prvního prvku, a rekurzivně aplikujeme
\lstinline{GetSmall}. Rekurzivní aplikací získáme zbytek seznamu, z něhož již byly odstraněny čísla
větší než čtyři. Jediné, v čem se liší jednotlivé větve podmínky (argumenty funkce \lstinline{If}),
je, zda zachováme první prvek seznamu, nebo ne. Pokud je prvek seznamu menší než pět, pomocí funkce
\lstinline{Cons} vytvoříme nový seznam přidáním prvního prvku původního seznamu na začátek seznamu
vytvořeného rekurzivní aplikací \lstinline{GetSmall}. Pokud je hodnota prvku pět nebo vyšší, vrátíme
pouze výsledek rekurzivní aplikace \lstinline{GetSmall} na zbytek seznamu a první prvek ignorujeme.

Jelikož jsou seznamy neměnné (chceme-li seznam jakkoliv změnit, naší jedinou možností je vytvořit
nový seznam), a protože jsou definovány induktivě (každý seznam je buď prázdný seznam, nebo buňka,
\textit{cons cell}, skládající se z prvního prvku seznamu, a podseznamu reprezentující zbytek
seznamu), jsou operace \lstinline{Cons}, \lstinline{Head}, \lstinline{Tail} (přesněji tedy operace,
které aplikace těchto funkcí představuje), proveditelné v konstantním čase.

Dále budeme chtít projít seznam, a vybrat jen ty prvky, které jsou větší než čtyři. Ihned se nabízí
možnost zkopírovat funkci \lstinline{GetSmall} a jen ji upravit, aby využila jiný predikát. Snad
není třeba uvádět, že tento postup je neideální, neboť v lambda kalkulu, a tedy i Transparentní
intenzionální logice, lze využívat funkce jako argumenty jiných funkcí. Proto zkopírujeme funkci
\lstinline{GetSmall}, novou funkci pojmenujeme \lstinline{Filter}, a přidáme nový argument,
predikát, funkci typu \lstinline{(Bool Int)}. Aplikace funkce \lstinline{GetSmall} nahradíme
rekurzivní aplikací \lstinline{Filter}, a namísto aplikace \lstinline{LessThanFive} aplikujeme
funkci zkonstruovanou provedením argumentu \lstinline{pred}.

Funkci \lstinline{Filter} můžeme jako predikát předat funkci \lstinline{LessThanFive}, a ověřit,
že aplikace funkce \lstinline{Filter} na seznam a predikát \lstinline{LessThanFive} je ekvivalentní
aplikaci \lstinline{GetSmall} na ekvivalentní seznam.

Funkci \lstinline{GetBig} poté definujeme pouze jako aplikaci funkce \lstinline{Filter} na seznam
a predikát \lstinline{\x: Int -> Bool ['> x '4]}.

Dále se pokusíme napsat funkci, která transformuje jednotlivé prvky seznamu, ale zachová počet
prvků. Takovou funkci tradičně ve funkcionálním programování nazýváme \lstinline{Map}, proto se
tohoto názvosloví budeme nyní držet. Funkce \lstinline{Map} přijímá dva argumenty -- seznam, a
funkci, pomocí které transformujeme jeden prvek seznamu. Nyní nám postačí jen jediná podmínka.
Pokud je seznam prázdný, vrátíme jej, jak jsme jej obdrželi -- není co transformovat. Pokud je seznam
neprázný, aplikujeme funkci reprezentovanou argumentem \lstinline{transform} na první prvek
seznamu, rekurzivně transformujeme zbytek seznamu, a nakonec vytvoříme nový seznam
z transformovaného zbytku a prvního prvku seznamu pomocí funkce \lstinline{Cons}. Poté stačí ověřit
funkčnost funkce \lstinline{Map} například tím, že si spočítáme druhé mocniny čísel v našem seznamu.

Poslední příklad jen ukazuje, že nemusíme definovat pouze seznamy čísel. Lze definovat také seznamy
individuí, funkcí, konstrukcí, apod. Seznamy jsou ovšem homogenní, nemůžou tedy obsahovat objekty
různého typu.

\begin{lstlisting}[caption={Funkce a uzávěry}, language=Tilscript]

-- Nejprve si vytvoříme seznam, se kterým budeme pracovat
numbers -> List(Int) := ['ListOf '1 '6 '2 '5 '3 '4].

-- Pomocná funkce -- predikát, který později využijeme
Defn LessThanFive(num: Int) -> Bool := ['< num '5].

-- Funkce GetSmall vrátí nový seznam obsahující pouze čísla
-- menší než pět
Defn GetSmall(list: List(Int)) -> List(Int) :=
    ['If ['IsEmpty list]
        -- Pokud je seznam prázdný, můžeme jej přímo vrátit
        list
        -- Jinak zkontrolujeme, zda je první prvek seznamu
        -- menší než pět, a pokud ano, uložíme jej na začátek
        -- seznamu získaného rekurzivní aplikací GetSmall
        ['If ['LessThanFive ['Head list]]
            ['Cons ['Head list] ['GetSmall ['Tail list]]]
            ['GetSmall ['Tail list]]]].

['Println ['GetSmall numbers]].

-- Predikát lze parametrizovat
-- Funkce Filter přijímá jako jeden z argumentů predikát,
-- který je využit namísto konkrétní funkce
Defn Filter(list: List(Int), pred: (Bool Int)) -> List(Int) :=
    ['If ['IsEmpty list]
        list
        ['If [pred ['Head list]]
            ['Cons ['Head list] ['Filter ['Tail list] pred]]
            ['Filter ['Tail list] pred]]].

['Println ['Filter numbers 'LessThanFive]].

Defn GetBig(list: List(Int)) -> List(Int) :=
    ['Filter list [\x: Int -> Bool ['> x '4]]].

['Println ['GetBig numbers]].

-- Pomocí funkce Map můžeme transformovat jednotlivé prvky seznamu
Defn Map(list: List(Int), transform: (Int Int)) -> List(Int) :=
    ['If ['IsEmpty list]
        list
        ['Cons
            [transform ['Head list]]
            ['Map ['Tail list] transform]]].

['Println ['Map numbers [\x: Int -> Int ['* x x]]]].

Karel, Petr, Adela/Indiv.

-- Seznamy jsou vždy homogenní, můžeme však mít seznamy
-- objektů libovolného typu, zde vytváříme seznam individuí
['Println ['ListOf 'Karel 'Petr 'Adela]].
\end{lstlisting}

\subsection{N-tice}

V další ukázce si vyzkoušíme práci s n-ticemi. N-tice jsou heterogenní kolekce přesně specifikované
délky. Délka n-tice je dána jejím typem.

V ukázce bude opět nutné importovat matematickou knihovnu.

N-tici můžeme vytvořit aplikací funkce \lstinline{MkTuple}. Funkce \lstinline{MkTuple} je podrobněji
popsáná v dokumentaci standardní knihovny, viz \ref{mk-tuple-fn}, zde pouze zmíníme, že se
jedná o syntaktický cukr podobný například funkci \lstinline{ListOf}, který nám umožňuje jednoduše
vytvářet n-tice.

Dále definujeme funkce \lstinline{Fst} a \lstinline{Snd}. Funkce jsou typově polymorfní a jejich
argument je typu \lstinline{Any1}. Argument musí být typu \lstinline{Any1}, aby bylo možné funkci
aplikovat na n-tice různé délky. Pokud by oborem hodnot funkce byly pouze n-tice přesně dané délky
$n$, mohli bychom jako typ argumentu explicitně uvést n-tici, a typ \lstinline{Any} využít pouze
pro prvky n-tice. Tedy například pro trojice bychom využili typ \lstinline{Tuple(Any1, Any2, Any3)}.

Funkce \lstinline{Fst} vrátí první prvek n-tice. Funkce \lstinline{Snd} vrátí druhý prvek n-tice.
Funkce \lstinline{Get} je obsažena ve standardní knihovně jazyka TIL-Script a vrátí prvek n-tice
na pozici $i$. Prvky n-tice jsou indexovány od nuly.

Pomocí funkce \lstinline{PrependToTuple} můžeme vytvořit novou $(n+1)$-tici přidáním prvku
na začátek již existující n-tice.

Nakonec si ukážeme možné reálné využití n-tic. Nejprve, pro zpřehlednění zápisu, pomocí výrazu
\lstinline{TypeDef} vytvoříme nové jméno, \lstinline{Vector2}, pro typ
\lstinline{Tuple(Real, Real)}. Tímto typem, jak název napovídá, budeme reprezentovat
dvoudimenzionální vektory. Dále definujeme funkci \lstinline{DotProduct}, která spočítá skalární
součin páru dvoudimenzionálních vektorů.

Poslední řádky ukázky ukazují funkcionalitu výrazu \lstinline{TypeDef}. Tyto výrazy nevytvoří nový
typ, pouze přiřadí jiné jméno již existujícímu typu. V našem programu vytvoříme dvě n-tice typu
\lstinline{Tuple(Real, Real)}, a dále jen aplikujeme funkci \lstinline{DotProduct} na naše vektory.

\begin{lstlisting}[caption={Práce s n-ticemi}, language=Tilscript]
Import "class://org.fpeterek.tilscript.math.Registrar".

-- Tvorba n-tice libovolné délky -- zde vytváříme trojici
triple -> Tuple(Int, Text, Construction) :=
    ['MkTuple ['+ '1 '3] ['IntToText '5] '['+ '3 '3]].

['Println triple].

-- Definice funkce přijímající n-tici libovolné délky
Defn Fst(tuple: Any1) -> Any2 :=
    ['Get tuple '0].

Defn Snd(tuple: Any1) -> Any2 :=
    ['Get tuple '1].

['Println ['Fst triple]].
['Println ['Snd triple]].

-- Vytvoření nové n-tice přidáním prvku na začátek již existující n-tice
quadruple -> Tuple(Real, Int, Text, Construction) :=
    ['PrependToTuple '3.0 triple].

['Println quadruple].

-- Vytvoření alternativního jména pro typ Tuple(Real, Real)
TypeDef Vector2 := Tuple(Real, Real).

-- Vytvoření funkce operující nad dvěma n-ticemi konkrétního typu
Defn DotProduct(v1: Vector2, v2: Vector2) -> Real :=
    ['+
        ['* ['Fst v1] ['Fst v2]]
        ['* ['Snd v1] ['Snd v2]]].

v1 -> Vector2 := ['MkTuple '2.0 '3.0].
v2 -> Vector2 := ['MkTuple '3.0 '2.0].

['Println ['DotProduct v1 v2]].
\end{lstlisting}

\subsection{Struktury}

Struktury, viz \peteref{structs}, slouží k vytvoření nového typu. Struktury jsou složené typy, které
nám umožňují rozlišit typy, které mají stejnou interní reprezentaci (tedy skládají se ze stejného
množství objektů stejného typu uspořádaných ve stejném pořadí).

V ukázce opět importujeme matematickou knihovnu a definujeme funkci \lstinline{PrettyPrint}.

Následně definujeme dva nové typy, \lstinline{Polar}, sloužící k reprezentaci polárních souřadnic,
a \lstinline{Cart}, reprezentující souřadnice kartézské. Na ukázce dobře vidíme, že oba typy mají
stejnou interní reprezentaci, tedy oba se skládají ze dvou objektů typu \lstinline{Real}. Pokud
bychom k reprezentaci kartézských i polárních souřadnic využili n-tice, oba druhy souřadnic by byly
reprezentovány typem \lstinline{Tuple(Real, Real)}. Poté by mohlo jednoduše dojít k záměně jednoho
druhu souřadnic za druhý. Typový systém by této záměně nedokázal zabránit. Vytvoření nového typu
nám umožňuje využít typovou kontrolu k zabránění chybné záměny souřadnic.

Abychom si předvedli práci se strukturami, vytvoříme si funkci pro převod kartézských souřadnic
na polární. Za tímto účelem si ovšem nejprve definujeme funkci \lstinline{GetAngle}. Argumenty
této funkce jsou souřadnice \lstinline{x}, \lstinline{y} bodu a vzdálenost tohoto bodu od počátku
v kartézském systému. V reálné implementaci by si funkce vzdálenost od počátku měla spočítat sama,
jelikož se však jedná pouze o pomocnou funkci, vzdálenost předáme jako argument, abychom ji nemuseli
počítat vícekrát. Funkce \lstinline{GetAngle} spočítá úhel mezi osou x a úsečkou definovanou
počátkem a bodem.

Funkce \lstinline{CartToPolar} převede kartézské souřadnice na polární. Jelikož ve funkci
potřebujeme využít vzdálenost bodu od počátku vícekrát, vytvoříme si pomocí uzávěru funkci, jejíž
argumentem je právě tato vzdálenost. Funkci vytvořenou uzávěrem poté okamžitě aplikujeme
na vypočítanou vzdálenost od počátku. V tomto případě uzávěr využíváme pouze ke zkrácení zápisu,
abychom nemuseli vícekrát uvádět vzorec Pythagorovy věty. V praxi ovšem můžeme pomocí uzávěrů
tímto způsobem omezit například vícenásobné provádění drahých operací (čtení z disku, komunikace
po síti), nebo zabránit možným chybám (například kdy opakovanou aplikací funkce \lstinline{Random}
získáme různá náhodná čísla). Ve funkci využijeme konstruktor struktury pro vytvoření objektu typu
\lstinline{Polar}. Následně jen vytvoříme proměnnou $v$-konstruující objekt typu \lstinline{Cart},
a převod mezi souřadnicemi otestujeme.

Druhou částí ukázky je definici rekurzivní struktury -- v tomto případě stromu. Každý strom se skládá
z hodnoty v kořenu stromu a seznamu podstromů. Po definici typu \lstinline{Tree} si jeden strom
ihned vytvoříme, abychom si mohli vyzkoušet práci se stromy.

Práci se stromy si vyzkoušíme implementací funkce \lstinline{Depth}, která spočítá hloubku stromu.
Hloubka stromu je rovna jedné, pokud strom nemá podstromy. Pokud má strom alespoň jeden podstrom,
přičteme číslo jedna k hloubce nejhlubšího podstromu.

K implementaci funkce \lstinline{Depth} potřebujeme také několik pomocných funkcí. Funkce
\lstinline{Depths} spočítá hloubky pro každý strom v seznamu stromů. Tuto funkci využijeme
k vypočtení hloubek podstromu. Funkce \lstinline{Max} vrátí největší hodnotu v seznamu celých
čísel, interně však tato funkce slouží pouze ke zjednodušení aplikaci rekurzivní funkce
\lstinline{MaxInt}, která rekurzivně projde celý seznam a v rekurzivních aplikacích si předává
nejvyšší nalezený prvek. Funkce \lstinline{MaxOf} pouze vrátí větší ze dvou celých čísel.

Nakonec provedeme výpis stromu i jeho hloubky.

K přístupu k atributu instance struktury (v příkladu k objektům typu \lstinline{Cart} a
\lstinline{Tree}) využíváme syntaktický konstrukt \lstinline{::}.

\begin{lstlisting}[caption={Práce se strukturami}, language=Tilscript]
Import "class://org.fpeterek.tilscript.math.Registrar".

Defn PrettyPrint(cons: Construction) -> Any1 :=
    ['Progn
        ['Print cons]
        ['Print '": "]
        ['Println ^2 cons]].

-- Definice typu reprezentujícího polární souřadnice
Struct Polar {
    dist: Real,
    angle: Real,
}.

-- Definice typu reprezentujícího kartézské souřadnice
Struct Cart {
    x: Real,
    y: Real,
}.

-- Výpočet úhlu mezi bodem a osou x
Defn GetAngle(x: Real, y: Real, len: Real) -> Real :=
    ['Cond
        ['= '0.0 len] '0.0
        ['> y '0.0] ['Acos ['/ x len]]
        'True ['- '360.0 ['Acos ['/ x len]]]].

-- Převod kartézských souřadnic na souřadnice polární
Defn CartToPolar(cart: Cart) -> Polar :=
    [[\dist: Real -> Polar
        {Polar dist ['GetAngle cart::x cart::y dist] }]
        ['Sqrt ['+ ['* cart::x cart::x] ['* cart::y cart::y]]] ].

cart -> Cart := {Cart '2.0 '2.0}.

['Println ['CartToPolar cart]].

-- Definice rekurzivní struktury
Struct Tree {
    value: Int,
    subtrees: List(Tree),
}.

-- Vytvoření stromu
myTree -> Tree := {Tree
    '1
    ['ListOf
        {Tree '2 {List(Tree) }}
        {Tree '3 ['ListOf {Tree '4 {List(Tree) } }]}]}.

-- Funkce vrátí větší ze dvou čísel
Defn MaxOf(fst: Int, snd: Int) -> Int :=
    ['If ['> fst snd] fst snd].

-- Funkce vrátí největší číslo v seznamu
-- Největší nalezené číslo je předáváno jako argument při rekurzivní aplikaci
Defn MaxInt(lst: List(Int), max: Int) -> Int :=
    ['If ['IsEmpty lst]
        max
        ['MaxInt ['Tail lst] ['MaxOf ['Head lst] max]]].


-- Funkce pouze rozloží seznam na první prvek a zbytek seznamu
-- a aplikuje rekurzivní funkci MaxInt
-- Funkce Max slouží ke zjednodušení aplikace MaxInt
Defn Max(lst: List(Int)) -> Int := ['MaxInt ['Tail lst] ['Head lst]].

-- Funkce Depths spočítá hloubky všech stromů v seznamu
Defn Depths(trees: List(Tree)) -> List(Int) :=
    ['If ['IsEmpty trees]
        {List(Int) }
        ['Cons
            ['Depth ['Head trees]]
            ['Depths ['Tail trees]]]].

-- Výpočet hloubky stromu
Defn Depth(tree: Tree) -> Int :=
    ['If ['IsEmpty tree::subtrees]
        '1
        ['+ '1 ['Max ['Depths tree::subtrees]]]].

['PrettyPrint 'myTree].
['PrettyPrint 'myTree::subtrees].
['PrettyPrint '['Depth myTree]].
\end{lstlisting}

\subsection{Intenze}

Všechny příklady zatím pracovali pouze s extenzemi. Důvodem bylo převážně zjednodušení ukázek.
Nyní si však ukážeme také příklad práce s intenzemi, neboť s nimi bezpochyby budeme chtít v praxi
pracovat.

V ukázce implementujeme intenze v jazyce TIL-Script. Databázi definujeme pomocí tzv. aktuálních
extenzí, tedy funkcí popisujících stav světa v konkrétních časovým okamžicích, případně intervalech,
pokud funkce popisuje interval okamžiků. Dále definujeme intenze,
které při extenzionalizaci podle dodaných argumentů správně vyberou aktuální extenzi popisující
požadovaný světamih. Databáze bude přiložena v příloze.

Kromě intenzí v databázi, která je součástí příkladu, definujeme také individua, se kterými budeme
pracovat. Konkrétně se jedná o individua \lstinline{Adela}, \lstinline{Karel} a \lstinline{Vaclav}.

Definice intenzí v jazyce TIL-Script je ovšem zdlouhavá a pro větší databázi může být velmi
nepřehledná. Pro praktické využití může být žádoucí využít databázové systémy pro uložení dat,
a pomocí již existující Java knihovny pro daný databázový systém vytvořit TIL-Script knihovnu,
která uživateli umožní s databází komunikovat.

V ukázce opět importujeme matematickou knihovnu. Dále importujeme také databázi obsahující potřebné
intenze. Soubor definující intenze se jmenuje \lstinline{intensions.tils}. Za účelem výpisu v ukázce
také definujeme funkci \lstinline{PrettyPrint}.

Jazyk TIL-Script definuje fyzickou reprezentaci časových okamžiků jako 64-bitové číslo, nijak však
nepředepisuje, jak má uživatel dané číslo intepretovat. Proto pro zjednodušení budeme v ukázce
využívat rozumně malá čísla, neboť využívání např. unixového času by vedlo ke špatně čitelné ukázce.

Proměnná \lstinline{w -> World} je definována ve standardní knihovně. V ukázce musíme definovat
pouze proměnnou \lstinline{t -> Time}, pomocí které budeme určovat časové okamžiky, které zkoumáme.
Hodnotu proměnné několikrát změníme, abychom mohli prozkoumat více časových okamžiků. Protože
v jazyce TIL-Script jsou časové okamžiky a čísla reprezentovány jiným typem, musíme literál celého
čísla konvertovat na časový okamžik pomocí funkce \lstinline{IntToTime}.

Také musíme deklarovat funkci \lstinline{LastDigit}, která vrátí poslední číslici reálného čísla,
pokud taková číslice existuje. Protože však funkci nepotřebujeme aplikovat, nemusíme ji definovat
(tedy dodávat předpis funkce), stačí nám pouze uvést její jméno a typ.

V ukázce ve většině případů využíváme notaci \lstinline{@wt}, která slouží pouze jako zkratka
za aplikaci intenze nejprve na svět, a následně aplikaci získané funkce na časový okamžik. Tato
notace je čistě syntaktická a parser jazyka TIL-Script ji přepíše na Kompozici během zpracování
a analýzy syntaktického stromu.

Součástí databáze je individuová role \lstinline{BestStudent/((Indiv Time) World)}, která
specifikuje nejlepšího studenta v daném okamžiku (podle naší arbitrárně zvolené metriky), a
funkce \lstinline{IsComputing/(((Bool Indiv Construction) Time) World)}, která uvádí, zda
uvedené individuum v daném světamihu počítá výraz představovaný konstrukcí.

Při výpisu nejlepšího studenta může na první pohled působit překvapivě dvojí trivializace. Zde je
třeba si uvědomit, že zápis \lstinline{@wt} slouží jako zkratka za Kompozici. Pravou trivializací
zmíníme funkci \lstinline{BestStudent}, kterou pomocí Kompozice extenzionalizujeme. Levá
trivializace poté trivializuje právě konstrukci extenzionalizace funkce \lstinline{BestStudent}.
Jelikož se jedná o individuovou roli, extenzionalizací získáme konkrétní individuum, ne funkci.
V příkladu s funkcí \lstinline{IsComputing} již extenzionalizaci provádíme jako podkonstrukci jiné
kompozice, jež získanou aktuální extenzi aplikuje na požadované argumenty.

Dále je již ukázka velmi přímočará. Pouze extenzionalizujeme žádané intenze v různých světamizích,
a zkoumáme stavy světa. Sledujeme, kdo byl nejlepším studentem v konkrétních časových okamžicích,
nebo jaké příklady studenti počítali. V předposlední větě programu pouze funkci
\lstinline{BestStudent} extenzionalizujeme pomocí explicitně uvedených Kompozic, abychom dokázali,
že zápis \lstinline{@wt} je čistě syntaktický a slouží pouze ke zkrácení zápisu.

\begin{lstlisting}[caption={Funkce a uzávěry}, language=Tilscript]
Import "class://org.fpeterek.tilscript.math.Registrar".
Import "intensions.tils".

Defn PrettyPrint(cons: Construction) -> Any1 :=
    ['Progn
        ['Print cons]
        ['Print '": "]
        ['Println ^2cons]].

t -> Time := ['IntToTime '130].

LastDigit/(Int Real).

['PrettyPrint ''BestStudent@wt].

['PrettyPrint '['IsComputing@wt 'Adela '['Ln '14.0]]].
['PrettyPrint '['IsComputing@wt 'Karel '['/ '18 '6]]].

t -> Time := ['IntToTime '250].

['Println 'BestStudent@wt].

['PrettyPrint '['IsComputing@wt 'Adela '['Ln '14.0]]].
['PrettyPrint '['IsComputing@wt 'Adela '['Cos 'Pi]]].
['PrettyPrint '['IsComputing@wt 'Karel '['/ '18 '6]]].

t -> Time := ['IntToTime '600].

['Println [['BestStudent w] t]].

['PrettyPrint '['IsComputing@wt 'Vaclav '['LastDigit 'Pi]]].
\end{lstlisting}

\section{Překlad programu}

Překladač byl psán pro platformu Java, proto pro spuštění překladače jazyka TIL-Script musíme mít
nainstalované Java prostředí (JRE). Máme-li JRE nainstalované, překladač můžeme spustit ručně, nebo
pomocí přiloženého pomocného skriptu.

Překladač spouštíme vždy z příkazové řádky, neboť pro něj momentálně neexistuje grafické rozhraní.

Při ručním spuštění je třeba manuálně spustit Java prostředí a specifikovat JAR soubor obsahující
kód TIL-Script překladače. Překladači je potřeba předat jako argument název souborů, které chceme
přeložit. Pokud je interpret TIL-Scriptu jediný Java archiv, který načítáme, není třeba specifikovat
tzv. \textit{Main Class}, tedy třídu obsahující statickou metodu \lstinline{void main()} (neboť
specifikace této třídy je součástí souboru \lstinline{manifest} obsaženém v archivu).

\begin{lstlisting}[caption={Spuštění překladače}]
java -jar tilscript.jar script.tils
\end{lstlisting}

Pokud chceme kromě překladače načíst také TIL-Script knihovny, musíme uvést nejen všechny archivy,
jenž potřebuje Java prostředí načíst, ale také hlavní třídu.

\begin{lstlisting}[caption={Spuštění překladače s načtením knihoven}]
java -cp tilscript.jar:libs/math.jar org.fpeterek.tilscript.interpreter.MainKt script.tils
\end{lstlisting}

\subsection{tilscript.sh}

Nejjednodušší způsob, jak překladač jazyka TIL-Script spustit, je využít pomocný skript
\lstinline{tilscript.sh}. Skript \lstinline{tilscript.sh} využívá pouze funkcionalitu definovanou
standardem POSIX, proto by tento skript měl fungovat korektně na všech operačních systémech
splňujících standard POSIX. Dále se standardu POSIX musí držet také shell, který bude tento pomocný
skript interpretovat\footnote{Můžeme tedy používat například ZSH nebo Bash. Naopak shell Fish není
kompatibilní se standardem POSIX, proto skript nebude schopen interpretovat.}.

Skript \lstinline{tilscript.sh} předpokládá, že se nachází ve stejné složce jako soubor
\lstinline{tilscript.jar}, tedy archiv obsahující přeložený kód překladače. Dále tento skript
předpokládá existenci adresáře \lstinline{libs/}, opět ve stejné složce, jako skript samotný.
Skript při spuštění automaticky načte všechny Java archivy ve složce \lstinline{libs/}, spustí
Java prostředí, zajistí načtení všech knihoven i TIL-Script překladače a korektně uvede hlavní
třídu překladače. Všechny argumenty, které skript obdrží, poté automaticky předá TIL-Script
překladači.

\begin{lstlisting}[caption={Spuštění překladače za využití pomocného skriptu}]
./tilscript.sh script.tils
\end{lstlisting}

\section{Standardní knihovna}

Standardní knihovna jazyka TIL-Script obsahuje základní funkce pro práci s objekty Transparentní
intenzionální logiky. Dále obsahuje definice atomických typů a tří proměnných. Z důvodu náročnosti
implementace některým funkcím chybí implementace, proto je můžeme pouze zmínit, nemůžeme však
provést jejich aplikaci.

Nakonec je třeba uvést, že současný stav nemusí reprezentovat také konečný stav standardní knihovny.
Na základě zpětné vazby uživatelů lze standardní knihovnu v budoucnu rozšiřovat.

\subsection{Funkce}

\subsubsection{Deklarace}

Zde uvedeným funkcím chybí implementace z důvodu její náročnosti a časové složitosti. Představme si
například všeobecný kvantifikátor. Logickou pravdivost řady tvrzení či úsudků lze dokázat například
pomocí důkazových kalkulů (rezoluční metoda, přirozená dedukce). Tyto metody dokazování jsou ovšem
čistě syntaktické, nedokáží tedy dokázat pravdivost tvrzení jako například $\forall x[P(x)]$. V takových
případech bychom se museli uchýlit k sémantické analýze predikátu $P$.
Predikát ovšem může být netriviální a jeho analýza velmi složitá. Iterace přes celý obor hodnot
predikátu je naopak nepraktická nebo nemožná. Pokud by predikát $P$ byla funkce typu $(o\tau)$
(nezapomeňme, že v Transparentní intenzionální logice pracujeme pouze s funkcemi), iterovat přes
obor hodnot by bylo nemožné, neboť množina reálných čísel je nespočetná. Množina všech validních
hodnot 64-bitového čísla s plovoucí řádovou čárkou spočetná je, proto je možné přes tato čísla
iterovat, není to však praktické, neboť by výpočet nemusel v skončit v rozumném čase.

\subsubsection*{Funkce: \lstinline|ForAll|}
Typ: \lstinline|(Bool (Bool Any1))|

Všeobecný kvantifikátor

\subsubsection*{Funkce: \lstinline|Exist|}
Typ: \lstinline|(Bool (Bool Any1))|

Existenční kvantifikátor

\subsubsection*{Funkce: \lstinline|Sing|}
Typ: \lstinline|(Bool (Bool Any1))|

Singularizátor

\subsubsection*{Funkce: \lstinline|Every|}
Typ: \lstinline|((Bool (Bool Any1)) (Bool Any1))|

Omezený kvantifikátor

\subsubsection*{Funkce: \lstinline|Some|}
Typ: \lstinline|((Bool (Bool Any1)) (Bool Any1))|

Omezený kvantifikátor

\subsubsection*{Funkce: \lstinline|No|}
Typ: \lstinline|((Bool (Bool Any1)) (Bool Any1))|

Omezený kvantifikátor

\subsubsection*{Funkce: \lstinline|Sub|}
Typ: \lstinline|(Construction Construction Construction Construction)|

Funkce \textit{Sub} substituční metody

\subsubsection*{Funkce: \lstinline|TrueC|}
Typ: \lstinline|(Bool Construction)|

Třída konstrukcí pravdivých ve všech valuacích $v$.

\subsubsection*{Funkce: \lstinline|FalseC|}
Typ: \lstinline|(Bool Construction)|

Třída konstrukcí nepravdivých ve všech valuacích $v$.

\subsubsection*{Funkce: \lstinline|ImproperC|}
Typ: \lstinline|(Bool Construction)|

Třída konstrukcí $v$-nevlastních pro všechny valuace $v$.

\subsubsection*{Funkce: \lstinline|TrueC|}
Typ: \lstinline|(Bool ((Bool Time) World))|

Třída propozic pravdivých ve všech valuacích $v$.

\subsubsection*{Funkce: \lstinline|FalseC|}
Typ: \lstinline|(Bool ((Bool Time) World))|

Třída propozic nepravdivých ve všech valuacích $v$.

\subsubsection*{Funkce: \lstinline|TrueC|}
Typ: \lstinline|(Bool ((Bool Time) World))|

Třída propozic $v$-nevlastních ve všech valuacích $v$.

\subsubsection{Definice}

Následující funkce již jsou definovány a lze provést jejich aplikaci na argumenty. Ke každé
funkci je přiložena ukázka jejího využití.

\subsubsection*{Funkce: \lstinline|+|, \lstinline|-|, \lstinline|*|, \lstinline|/|}

Typ: \lstinline{(Int Int Int)}, \lstinline{(Real Real Real)}

Aritmetické operace. Tyto funkce jsou definovány jak pro reálná, tak pro celá čísla, oba argumenty
však musí být stejného typu.

\begin{lstlisting}[caption={Ukázka využití aritmetických operací}]
['+ '1 '2].
['* '3.14159 '2.71828].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|=|}

Typ: \lstinline{(Bool Any1 Any1)}

Funkce \lstinline{=} slouží k porovnávání objektů. Porovnání objektů je automaticky definováno
pro všechny typy, včetně seznamů, n-tic, i uživatelem definovaných struktur. Porovnávání
objektů molekulárních typů probíhá prvek po prvku.

\begin{lstlisting}[caption={Ukázka využití funkce =}]
['= ['ListOf '1 '2 '3] ['Cons '1 ['ListOf '2 '3]]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|ListOf|}

\lstinline{ListOf} slouží pouze jako syntaktický cukr pro tvorbu seznamů. \lstinline{ListOf}
aplikujeme na alespoň jeden argument, počet argumentů je ale shora neomezený. Jediným omezením je,
že všechny argumenty musí být stejného typu. Parser jazyka TIL-Script poté aplikaci
\lstinline{ListOf} převede na korektní sestavení seznamu pomocí funkcí \lstinline{ListOfOne} a
\lstinline{Cons}.


\begin{lstlisting}[caption={Ukázka využití ListOf}]
-- Následující dvě konstrukce jsou ekvivalentní
['ListOf '1 '2 '3 '4].
['Cons '1 ['Cons '2 ['Cons '3 ['ListOfOne '4]]]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|ListOfOne|}
Typ: \lstinline{(List(Any1) Any1)}

Funkce \lstinline{ListOfOne} vytvoří seznam obsahující jediný prvek.

\begin{lstlisting}[caption={Ukázka využití ListOfOne}]
['ListOfOne 'Pi].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|Cons|}
Typ: \lstinline{(List(Any1) Any1 List(Any1))}

Funkce \lstinline{Cons} vytvoří nový seznam vložením prvku na začátek již existujícího seznamu.
Jelikož jsou seznamy definovány induktivně, a zároveň jsou neměnné, není třeba již existující seznam
kopírovat. Proto lze tuto operaci provést v konstantním čase.

\begin{lstlisting}[caption={Ukázka využití Cons}]
['Cons 'Pi ['ListOf '1 '2 '3]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|Head|}
Typ: \lstinline{(Any1 List(Any1))}

Funkce \lstinline{Head} vrátí první prvek seznamu. Seznam musí být neprázdný, v opačném případě
funkce nevrací nic (vrací \lstinline{Nil}).

\begin{lstlisting}[caption={Ukázka využití Head}]
['Head ['ListOf '1 '2 '3]]. -- Konstruuje 1
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|Tail|}
Typ: \lstinline{(List(Any1) List(Any1))}

Funkce \lstinline{Tail} vrátí seznam bez jeho prvního prvku. Funkce je nedefinovaná pro prázdné
seznamy.

\begin{lstlisting}[caption={Ukázka využití Head}]
['Tail ['ListOf '1 '2 '3]]. -- Konstruuje seznam [2, 3]
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|IsEmpty|}
Typ: \lstinline{(Bool List(Any1))}

Aplikací \lstinline{IsEmpty} na prázdný seznam získáme hodnotu \lstinline{True}. Aplikací
na neprázdný seznam získáme \lstinline{False}.

\begin{lstlisting}[caption={Ukázka využití IsEmpty}]
['IsEmpty ['ListOf '1 '2 '3]]. -- False
['IsEmpty ['Tail ['ListOfOne '1]]]. -- True
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|EmptyListOf|}
Typ: \lstinline{(List(Any1) Type)}

Funkce \lstinline{EmptyListOf} jako svůj jediný vstup přijímá objekt typu \lstinline{Type}.
Výsledkem aplikace na typ je poté prázdný seznam objektů specifikovaného typu.

\begin{lstlisting}[caption={Ukázka využití EmptyListOf}]
['IsEmptyOf 'Int].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|Print|, \lstinline{Println}}
Typ: \lstinline{(Any1 Any1)}

Funkce \lstinline{Print}, \lstinline{Println} zajistí výpis svého argumentu na standardní výstup
programu a poté vrátí svůj jediný argument. Funkce \lstinline{Println} vypíše také oddělovač řádků
(v systému GNU/Linux znak LF, v systému Windows sekvenci CRLF). Funkce \lstinline{Print} tento
oddělovač nevypisuje.

\begin{lstlisting}[caption={Ukázka využití Print, Println}]
['Println '['+ '1 '2]]. -- Vypíše konstrukci ['+ '1 '2]
['Print ['+ '1 '2]]. -- Vypíše konstrukci ['+ '1 '2]
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{If}}
Typ: \lstinline{(Any1 Bool Any1 Any1)}

Funkce \lstinline{If} je, narozdíl od všech ostatních funkcí, prováděna líně. Funkce \lstinline{If}
přijímá tři argumenty. První argument je objekt typu \lstinline{Bool}. Druhým argumentem je hodnota,
kterou funkce vrátí, je-li první argument \lstinline{True}. Jinak funkce \lstinline{If} vrátí svůj
druhý argument. Konstrukce, která konstruuje argument funkce \lstinline{If}, je ovšem provedena až
poté, co překladač zkontroluje hodnotu prvního argumentu, aby nedošlo ke zbytečnému provedení
konstrukce a následnému zahození výsledku.

\begin{lstlisting}[caption={Ukázka využití If}]
['If ['> x y]
    ['Println '"x is greater than y"]
    ['Println '"y is greater than or equal to x"]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Cond}}\label{cond-documentation}

\lstinline{Cond} slouží pouze jako syntaktický cukr pro funkci \lstinline{If}. \lstinline{Cond} tedy
není funkcí sama o sobě, překladačem je ovšem při procesu tvorby AST přeložena na sérii vnořených
aplikací funkce \lstinline{If}.

Máme-li pouze jednu podmínku se dvěma větvemi, \textit{if} a \textit{else}, je využití funkce
\lstinline{If} jednoduché a čitelné. Máme-li však větví více, musíme aplikace funkce \lstinline{If}
zanořit -- větví \textit{else} tak musí být další aplikace \lstinline{If}.

Syntaktický cukr \lstinline{Cond} nám umožňuje zjednodušit zápis funkce \lstinline{If} a vyhnout
se zanořování. \lstinline{Cond} přijímá nespecifikovaný, avšak sudý počet argumentů. Lichým
argumentem je vždy podmínka. Sudým argumentem je poté konstrukce, která se provede, je-li podmínka
pravdivá. Překladač během překladu přeloží aplikaci \lstinline{Cond} na zanořené aplikace funkce
\lstinline{If}. Podmínky se tedy nevyhodnocují všechny najednou, ale jedna po druhé, dokud není
nalezena první pravdivá podmínka. Není-li pravdivá ani jedna podmínka, \lstinline{Cond} vrací
\lstinline{Nil}.

\begin{lstlisting}[caption={Ukázka využití Cond}]
['Cond
    ['= x '2] ['Log2 y]
    ['= x '10] ['Log10 y]
    'True ['Ln y]]. -- catch-all podmínka
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Progn}}\label{progn-fn}
Typ: \lstinline{(Any2 Any1 Any2)}

Funkce \lstinline{Progn} přijímá dva argumenty. První argument ignoruje, druhý argument vrátí, jak
jej dostala. Funkce \lstinline{Progn} je tedy ekvivalentem funkce \textit{False} lambda kalkulu
($\lambda x \lambda y . y$, případně $\lambda x, y y$ v TIL). Díky principu kompozicionality je aplikace
\lstinline{Progn} $v$-nevlastní, neobdrží-li první argument. V takovém případě tedy vůbec nedojde
k vyhodnocení druhého argumentu.

Funkci \lstinline{Progn} využijeme například při výpisu do souboru nebo na standardní výstup.
Pro analýzu přirozeného jazyka většinou není potřeba. Kódovat přirozená čísla pomocí Churchova
kódování v Transparentní intenzionální logice také nepotřebujeme.

Funkce \lstinline{Progn} je binární funkcí, existuje pro ni ovšem podobný syntaktický cukr, jako pro
\lstinline{Cond} nebo \lstinline{ListOf}. Předáme-li funkci \lstinline{Progn} více než dva
argumenty, překladač aplikaci \lstinline{Progn} na více argumentů rozepíše na vnořené aplikace
binární funkce \lstinline{Progn}. Narozdíl od \lstinline{Cond}, \lstinline{Progn} je tedy
skutečnou funkcí.

Název \lstinline{Progn} je převzat z jazyka Lisp.

\begin{lstlisting}[caption={Ukázka využití Progn}]
-- Vypíše 'x + y = ' a součet x a y
-- Vrátí součet x+y, protože Println vrátí svůj argument
['Progn
    ['Print '"x + y = "]
    ['Println ['+ x y]]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Tr}}
Typ: \lstinline{(Construction Any1)}

Trivializuje svůj argument.

\begin{lstlisting}[caption={Ukázka využití Tr}]
['Tr ['+ '1 '2]]. -- Kompozice konstruuje '3
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{TypeOf}}
Typ: \lstinline{(Type Any1)}

Vrátí typ svého argumentu. Může být užitečné například v typově polymorfních funkcích,
potřebujeme-li provést rozhodnutí na základě typu argumentu.

\begin{lstlisting}[caption={Ukázka využití TypeOf}]
-- Volba funkce na základě typu argumentu typově polymorfní funkce
[\x: Any1 -> Any1 [['If ['= ['TypeOf x] 'Int] 'DiscreteLog 'Log10] x]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{IsNil}}
Typ: \lstinline{(Bool Any1)}

Vrátí \lstinline{True}, neobdrží-li žádný argument (tedy je-li argumentem \lstinline{Nil}). Tato
funkce porušuje princip kompozicionality, je ovšem potřeba např. k ošetření chyb.

\begin{lstlisting}[caption={Ukázka využití IsNil}]
x -> Real = ['/ a b].
['If ['IsNil x]
    -- Vypíšeme chybu a ukončíme program
    ['Progn
        ['Println '"Program obdržel nesprávný vstup"]
        ['Exit '-1]]
    -- Program obdržel validní vstup, hodnota 1 bude ignorována
    '1].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Exit}}

Aplikací funkce \lstinline{Exit} ukončíme překlad programu. Argument funkce určuje návratovou
hodnotu programu.

\begin{lstlisting}[caption={Ukázka využití Exit}]
x -> Real = ['/ a b].
['If ['IsNil x]
    -- Vypíšeme chybu a ukončíme program
    ['Progn
        ['Println '"Program obdržel nesprávný vstup"]
        ['Exit '-1]]
    -- Program obdržel validní vstup, hodnota 1 bude ignorována
    '1].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{RandomInt}}
Typ: \lstinline{(Int DeviceState)}

Funkce \lstinline{RandomInt} vrací náhodné celé číslo v intervalu $\bigl \langle 0; 2^{64}-1 \bigr \rangle$.

\begin{lstlisting}[caption={Ukázka využití RandomInt}]
['RandomInt deviceState].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Random}}
Typ: \lstinline{(Real DeviceState)}

Funkce \lstinline{Random} vrací náhodné reálné číslo v intervalu $\bigl \langle 0; 1 \bigr \rangle$.

\begin{lstlisting}[caption={Ukázka využití Random}]
['* ['Random deviceState] '100]. -- náhodné číslo v rozsahu 0-100
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Not}}
Typ: \lstinline{(Bool Bool)}

Logická negace.

\begin{lstlisting}[caption={Ukázka využití Not}]
['Not ['= x y]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{And}}
Typ: \lstinline{(Bool Bool Bool)}

Logická konjunkce.

\begin{lstlisting}[caption={Ukázka využití And}]
[And ['= x y] ['= x z]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Or}}
Typ: \lstinline{(Bool Bool Bool)}

Logická disjunkce.

\begin{lstlisting}[caption={Ukázka využití Or}]
[Or ['= x y] ['= x z]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Implies}}
Typ: \lstinline{(Bool Bool Bool)}

Implikace.

\begin{lstlisting}[caption={Ukázka využití Implies}]
['Implies ['And ['= x y] ['= x z]] ['= y z]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{OneTuple}}
Typ: \lstinline{(Tuple(Any1) Any1)}

Vytvoří n-tici obsahující právě jeden prvek -- obdržený argument. Lze využít například při rekurzivní
tvorbě n-tice.

\begin{lstlisting}[caption={Ukázka využití OneTuple}]
['OneTuple '1].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{MkTuple}}\label{mk-tuple-fn}

\lstinline{MkTuple} slouží jako syntaktický cukr pro tvorbu n-tic. \lstinline{MkTuple} přijímá
nespecifikovaný počet argumentů, překladačem je poté přeložena na aplikaci \lstinline{OneTuple}
a následné vložení prvků na začátek n-tice.

\begin{lstlisting}[caption={Ukázka využití OneTuple}]
['MkTuple '1 '3.5 'True].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{PrependToTuple}}
Typ: \lstinline{(Any1 Any2 Any3)}

\lstinline{PrependToTuple} přijímá dva argumenty. Prvním argumentem je libovolná hodnota. Druhý
argument musí být vždy n-tice. \lstinline{PrependToTuple} vytvoří novou (n+1)-tici vložením prvního
argumentu na začátek n-tice specifikované druhým argumentem.

\begin{lstlisting}[caption={Ukázka využití PrependToTuple}]
['PrependToTuple '4 ['MkTuple '1 '3.5 'True]]. -- Vytvoří n-tici (4, 1, 3.5, True)
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Get}}
Typ: \lstinline{(Any1 Any2 Int)}

Funkce \lstinline{Get} umožňuje získat prvek n-tice na požadované pozici. Prvním argumentem je
n-tice, druhým je index prvku. Prvky indexujeme od nuly. Funkce \lstinline{Get} je nedefinovaná,
je-li index větší nebo roven velikosti n-tice.

\begin{lstlisting}[caption={Ukázka využití Get}]
['Get '1 ['MkTuple 'E 'Pi]]. -- Pi
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{TupleLen}}
Typ: \lstinline{(Int Any1)}

Funkce \lstinline{TupleLen} vrátí délku n-tice. Využití funkce je převážně v typově polymorfních
funkcích, neboť není-li funkce typově polymorfní, museli jsme typ explicitně uvést, a tedy délku
n-tice známe. Argumentem musí být n-tice, funkce je typově polymorfní proto, aby argumentem mohly
být n-tice libovolné délky.

\begin{lstlisting}[caption={Ukázka využití TupleLen}]
-- vynásobíme první prvek n-tice délkou n-tice
[\x: Any1 -> Int ['* ['TupleLen x] ['Get x '0]]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Char}}
Typ: \lstinline{(Text Text Int)}

Funkce \lstinline{Char} vrátí znak textového řetězce na požadované pozici. Prvky indexujeme od nuly.
Funkce \lstinline{Char} je nedefinovaná, je-li index větší nebo roven velikosti řetězce.


\begin{lstlisting}[caption={Ukázka využití Char}]
['Char '"TIL" '1]. -- "I"
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{CatS}}
Typ: \lstinline{(Text Text Text)}

Funkce \lstinline{CatS} spojí dva textové řetězce.

\begin{lstlisting}[caption={Ukázka využití Char}]
-- Kompozice konstruuje řetězec "Transparentní intenzionální logika"
['CatS '"Transparentní intenzionální" '" logika"].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{HeadS}}
Typ: \lstinline{(Text Text)}

Funkce \lstinline{HeadS} vrátí první znak řetězce. Funkce je nedefinovaná pro prázdné řetězce.

\begin{lstlisting}[caption={Ukázka využití HeadS}]
['HeadS '"TIL"]. -- "T"
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{TailS}}
Typ: \lstinline{(Text Text)}

Funkce \lstinline{HeadS} vrátí řetězec bez prvního znaku. Funkce je nedefinovaná pro prázdné
řetězce.

\begin{lstlisting}[caption={Ukázka využití TailS}]
[TailS '"TIL"]. -- "IL"
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{LenS}}
Typ: \lstinline{(Int Text)}

Funkce \lstinline{LenS} vrátí délku textového řetězce.

\begin{lstlisting}[caption={Ukázka využití LenS}]
[LenS '"TIL"]. -- 3
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{IsBefore}, \lstinline{IsBeforeOrEq}, \lstinline{IsAfter},
  \lstinline{IsAfterOrEq}}
Typ: \lstinline{(Bool Time)}

Funkce slouží k porovnávání časových okamžiků. Pro obyčejnou rovnost lze využít funkci
\lstinline{=}.

\begin{lstlisting}[caption={Ukázka porovnávání časových okamžiků}]
['IsBefore t1 t2].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Now}}
Typ: \lstinline{(Time DeviceState)}

Funkce \lstinline{Now} vrátí aktuální systémový čas.

\begin{lstlisting}[caption={Ukázka využití Now}]
[['PrezidentCR ['Now deviceState]] w].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{IntToText},
\lstinline{RealToText},
\lstinline{IntToTime},
\lstinline{TextToInt},
\lstinline{TextToReal},
\lstinline{TimeToInt},
\lstinline{IntToReal},
\lstinline{RealToInt}
}

Funkce slouží k převodu mezi typy. Při převodu z reálných čísel na čísla celá dochází k ořezání
čísla (zaokrouhlení směrem k nule).

\begin{lstlisting}[caption={Ukázka využití konverzí}]
['Log ['IntToReal ['+ '2 '3]]].
['CatS '"Log 10 = " ['RealToText ['Log '10]]].
\end{lstlisting}

\subsubsection*{Funkce:
\lstinline{IsVariable},
\lstinline{IsComposition},
\lstinline{IsClosure},
\lstinline{IsExecution},
\lstinline{IsFunction},
\lstinline{IsTrivialization},
\lstinline{IsSymbol},
\lstinline{IsList},
\lstinline{IsValue},
\lstinline{IsTuple},
\lstinline{IsConstruction},
\lstinline{IsStruct}
}

Typ: \lstinline{(Bool Any1)}

Tyto funkce umožňují ověřit, zda je argument konkrétní hodnotou (\lstinline{IsValue}), symbolickou
hodnotou (\lstinline{IsSymbol}), seznamem, n-ticí, strukturou nebo konstrukcí. Také nám umožňují
určit, o jaký typ konstrukce se jedná.

\begin{lstlisting}[caption={Ukázka využití IsSymbol}]
[\x: Int -> Int
    ['If ['IsSymbol x]
        Nil -- neumíme umocnit symbolickou hodnotu
        ['* x x]]]. -- konkrétní hodnotu umocníme
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{NilAt}}\label{nilat-fn}
Typ: \lstinline{(Int Text Tuple(Int Int Text))}

Funkce \lstinline{NilAt} je nedefinována na všech argumentech. Funkce umožňuje zkonstruovat hodnotu
\lstinline{Nil}. \lstinline{Nil} jde také zmínit přímo, \lstinline{NilAt} nám ovšem umožňuje vnitřní
reprezentaci \lstinline{Nil} obohatit také o důvod, proč byla konstrukce $v$-nevlastní, a pozici,
kde byla zavolána funkce, jež \lstinline{Nil} vrátila. Tímto způsobem můžeme dosáhnout lepšího
hlášení chyb.

Argumentem funkce je důvod, proč byla vrácena hodnota \lstinline{Nil}, a pozice, kde došlo
k aplikaci funkci na argumenty, na kterých není definována. Často zde budeme chtít použít proměnnou
\lstinline{callsite}, viz \peteref{callsite-var}.

Ukázka je schválně jednoduchá, logaritmus v matematické knihovně tuto situaci řeší sám, v praxi tedy
není třeba kontrolovat argument logaritmu manuálně. Proměnná \lstinline{callsite} konstruuje
pozici ve zdrojovém kódu, kde došlo k aplikaci funkce konstruované uzávěrem.

\begin{lstlisting}[caption={Ukázka využití NilAt}]
[\x: Real -> Real
    ['If ['Not ['> x 0.0]]
        ['NilAt '"Argument logaritmu musí být kladný" 'callsite]
        ['Log x]]].
\end{lstlisting}

%TODO: Continue if necessary

\subsection{Typy}

Standardní knihovna jazyka TIL-Script definuje atomické typy popsané v kapitole
\peteref{tilscript-chapter}, tedy typy
\lstinline{Bool}, \lstinline{Type}, \lstinline{Int}, \lstinline{Text}, \lstinline{Indiv},
\lstinline{Real}, \lstinline{Time}, \lstinline{World}, \lstinline{DeviceState}.

Dále definuje seznamy a n-tice. Žádné struktury standardní knihovna nedefinuje.

\subsection{Proměnné}

Standardní knihovna definuje pouze tři proměnné.

\subsubsection{\lstinline{w -> World}}

Proměnná \lstinline{w} označuje současný svět. Objekty typu \lstinline{World} nemají žádnou
inherentní hodnotu, využívají se hlavně k označení intenzí. Proměnná \lstinline{w} proto existuje,
aby si ji uživatel nemusel explicitně vytvářet sám.

\subsubsection{\lstinline{deviceState -> DeviceState}}

Proměnná \lstinline{deviceState} existuje ze stejného důvodu, jako proměnná \lstinline{w}. Objekty
typu \lstinline{DeviceState} nemají žádnou konkrétní hodnotu a jsou využívány pouze pro označení
funkcí, jejichž hodnota závisí na stavu zařízení, na němž je program spuštěn.

\subsubsection{\lstinline{callsite -> Tuple(Text Int Int)}}\label{callsite-var}

Proměnná \lstinline{callsite} je automaticky vytvářená proměnná. Proměnná \lstinline{callsite}
je vytvořena při aplikaci funkce, a obsahuje pozici ve zdrojovém kódu, kde byla aplikace funkce
provedena. Proměnná slouží především k umožnění lepšího hlášení chyb.

Proměnná slouží převážně jako argument funkce \lstinline{NilAt}, viz~\ref{nilat-fn}.

\section{Matematická knihovna}

Matematická knihovna slouží také jako ukázka tvorby TIL-Script knihoven v jazycích kompilovaných
do JVM bytekódu, nebo jako test importu jmen z Java archivů. Přesto obsahuje několik užitečných
definic. Narozdíl od standardní knihovny, všechny funkce matematické knihovny jsou plně
definované, a lze tedy provést jejich aplikaci na argumenty.

\subsection{Funkce}

\subsubsection*{Funkce: \lstinline{Sin}}
Typ: \lstinline{(Real Real)}

Funkce sinus. Kromě konkrétních hodnot je definována také pro symbolickou hodnotu
\lstinline{Pi/Real}.

\begin{lstlisting}[caption={Ukázka využití Sin}]
['Sin 'Pi]. -- 0
['Sin ['/ '3.14159 '2.0]]. -- přibližně 1
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Asin}}
Typ: \lstinline{(Real Real)}

Inverzní funkce k funkci sinus.

\begin{lstlisting}[caption={Ukázka využití Asin}]
['Asin '0.5].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Cos}}
Typ: \lstinline{(Real Real)}

Funkce cosinus. Kromě konkrétních hodnot je definována také pro symbolickou hodnotu
\lstinline{Pi/Real}.

\begin{lstlisting}[caption={Ukázka využití Cos}]
['Cos 'Pi]. -- -1
['Cos ['/ '3.14159 '2.0]]. -- přibližně 0
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Acos}}
Typ: \lstinline{(Real Real)}

Inverzní funkce k funkci kosinus.

\begin{lstlisting}[caption={Ukázka využití Acos}]
['Acos '0.5].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Tan}}
Typ: \lstinline{(Real Real)}

Funkce tangens. Kromě konkrétních hodnot je definována také pro symbolickou hodnotu
\lstinline{Pi/Real}.

\begin{lstlisting}[caption={Ukázka využití Tan}]
['Tan 'Pi]. -- 0
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Ln, Log2, Log10}}
Typ: \lstinline{(Real Real)}

Přirozený logaritmus, logaritmus o základu dvě a logaritmus o základu 10. Přirozený logaritmus
je definován také pro symbolickou hodnotu \lstinline{E/Real}.

\begin{lstlisting}[caption={Ukázka využití Ln, Log2, Log10}]
['Ln ['* '2.71828 '2.71828]]. -- Přibližně 2
['Log2 '1024]. -- 10
['Log10 '1000]. -- 3
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Log}}
Typ: \lstinline{(Real Real Real)}

Logaritmus o libovolném základu. Prvním argumentem je číslo, jehož logaritmus chceme spočítat,
druhým argumentem je základ logaritmu.

\begin{lstlisting}[caption={Ukázka využití Log}]
['Log '27.0 '3.0]. -- 3
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Round}}
Typ: \lstinline{(Real Real)}

Funkce \lstinline{Round} umožňuje zaokrouhlit reálné číslo na jednotky.

\begin{lstlisting}[caption={Ukázka využití Round}]
['Round '3.2]. -- 3
['Round '3.7]. -- 4
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Sqrt}}
Typ: \lstinline{(Real Real)}

Funkce \lstinline{Sqrt} vrátí druhou odmocninu svého argumentu.

\begin{lstlisting}[caption={Ukázka využití Round}]
['Round '3.2]. -- 3
['Round '3.7]. -- 4
\end{lstlisting}

\subsection{Symbolické hodnoty}

\subsubsection*{Hodnota \lstinline{Pi/Real}}

Hodnota \lstinline{Pi} nám umožňuje symbolicky zmínit číslo $\pi$, viz \peteref{symbolic-values}.

\begin{lstlisting}[caption={Ukázka využití Pi}]
['Sin 'Pi].
\end{lstlisting}

\subsubsection*{Hodnota \lstinline{E/Real}}

Hodnota \lstinline{E} nám umožňuje symbolicky zmínit Eulerovo číslo $e$,
viz \peteref{symbolic-values}.

\begin{lstlisting}[caption={Ukázka využití E}]
['Ln 'E].
\end{lstlisting}

\subsection{Proměnné}

\subsubsection*{Proměnná \lstinline{pi -> Real}}

Proměnná \lstinline{pi -> Real} aproximuje číslo $\pi$ s přesností na 15 desetinných míst.

\begin{lstlisting}[caption={Ukázka využití proměnné pi}]
['* pi '2]. -- přibližně 6.28
\end{lstlisting}

\subsubsection*{Proměnná \lstinline{e -> Real}}

Proměnná \lstinline{e -> Real} aproximuje Eulerovo číslo s přesností na 15 desetinných míst.

\begin{lstlisting}[caption={Ukázka využití proměnné e}]
['Ln ['* e ['* e e]]]. -- 3
\end{lstlisting}

\section{Implementace knihovny}

Nyní si ukážeme, jak implementovat vlastní TIL-Script knihovnu v jazyce Java. Ukázku implementace
v jazyce Kotlin přiložíme za účelem porovnávání těchto dvou jazyků v příloze. V praxi lze využít
libovolný jazyk kompilovaný pro platformu JVM, nejen Javu nebo Kotlin. Implementovat budeme funkci
\lstinline{InvSqrt/(Real Real)}, tedy převrácenou hodnotu druhé odmocniny.

\subsection{Implementace funkce}

Začneme vytvořením třídy \lstinline{InvSqrt}. Tato třída musí být potomkem třídy
\lstinline{DefaultFunction}, abychom ji mohli použít jako TIL-Script funkci.

\begin{lstlisting}[caption={Třída InvSqrt}, language=Java]
public class InvSqrt extends DefaultFunction {

}
\end{lstlisting}

Následně musíme implementovat konstruktor třídy \lstinline{InvSqrt}. V konstruktoru musíme zavolat
konstruktor předka -- třídy \lstinline{DefaultFunction}. Konstruktor \lstinline{DefaultFunction}
přijímá tři argumenty.

Prvním je jméno funkce -- tímto jménem budeme funkci označovat v jazyce TIL-Script. Na jméně třídy,
která danou funkci reprezentuje, nezáleží, kvůli přehlednosti je však vhodné třídu pojmenovat podle
názvu funkce.

Druhým argumentem je obor hodnot -- typ objektu, který funkce vrátí. Abychom si zkrátili zápis,
vytváříme v kódu statickou proměnnou \lstinline{real}.

Třetím argumentem je seznam proměnných -- argumentů funkce. Zde nám postačí jeden argument. Opět
vytvoříme pomocnou proměnnou, tentokrát pojmenovanou \lstinline{arg}. Konstruktor třídy
\lstinline{Variable} přijímá pět argumentů. Prvním je název proměnné. Druhým argumentem je pozice
ve zdrojovém kódu -- tento argument se využívá v parseru jazyka TIL-Script a využívá se k hlášení
chyb. Jelikož je funkce implementovaná v Javě, ne v jazyce TIL-Script, nastavíme pozici na hodnotu,
která značí, že je pozice neznámá. Třetí argument konstruktoru určuje typ proměnné. Čtvrtým
argumentem je seznam chyb hlášených při definici proměnné -- jelikož nechceme zbytečně hlásit chyby
pro vlastní proměnnou, vytvoříme prázdný seznam. Posledním argumentem je hodnota proměnné. Jelikož
se ale jedná o argument funkce, není potřeba žádnou hodnotu dodávat. Při aplikaci funkce se vždy
danému argumentu nastaví korektní hodnota. Nakonec tedy vytvoříme seznam obsahující tento jeden
argument.

\begin{lstlisting}[caption={Konstruktor InvSqrt}, language=Java]

  private static AtomicType real = Primitives.INSTANCE.getReal();

  private static Variable arg = new Variable(
    "x",
    new SrcPosition(-1, -1, ""),
    real,
    new ArrayList<>(),
    null
  );

  public InvSqrt() {
    super(
      "InvSqrt",
      real,
      Collections.singletonList(arg)
      );
  }
\end{lstlisting}

Nakonec musíme naprogramovat sémantiku funkce \lstinline{InvSqrt}. Za tímto účelem musíme vytvořit
metodu \lstinline{apply}. Jelikož přepisujeme zděděnou abstraktní metodu, můžeme si ji nechat
vygenerovat vývojovým prostředím nebo jazykovým serverem.

Jakmile máme vygenerovanou hlavičku funkce, stačí funkci naprogramovat. Funkce přijímá pouze jeden
argument, proto si tento argument uložíme do pomocné proměnné, abychom nemuseli při každém
přístupu k argumentu indexovat seznam argumentů.

Následně se ujistíme, že je argument Java objektem typu \lstinline{Real}. Díky typové kontroly víme,
že argument bude reálné číslo, pouze nevíme, zda se jedná o konkrétní číslo (Java objekt typu
\lstinline{Real} reprezentující reálná čísla), nebo o symbolickou hodnotu (Java objekt typu
\lstinline{Symbol}). Pokud argumentem není konkrétní hodnota, bohužel nevíme, jakou hodnotu
potřebujeme odmocnit.

Následně potřebujeme získat hodnotu argumentu jako proměnnou typu \lstinline{double}, abychom
mohli provádět matematické operace v jazyku Java.

Dále se musíme ujistit, že funkce obdržela argument, na kterém je definovaná.

Poté už stačí jen spočítat výsledek a vrátit objekt typu \lstinline{Real}, reprezentující reálné
číslo v jazyce TIL-Script.

\begin{lstlisting}[caption={Konstruktor InvSqrt}, language=Java]
  @NotNull
  @Override
  public Construction apply(
    @NotNull InterpreterInterface interpreterInterface,
    @NotNull List<? extends Construction> args,
    @NotNull FnCallContext ctx) {

    final Construction arg = args.get(0);

    if (! (arg instanceof Real)) {
      return new Nil(
        ctx.getPosition(),
        new ArrayList<>(),
        "Argument of InvSqrt must not be symbolic"
      );
    }

    final double value = ((Real) arg).getValue();

    if (value <= 0.0) {
      return new Nil(
        ctx.getPosition(),
        new ArrayList<>(),
        "Argument of InvSqrt must be greater than zero"
      );
    }

    final double res = 1.0 / Math.sqrt(value);

    return new Real(res, ctx.getPosition(), new ArrayList<>());
  }
\end{lstlisting}

Metoda \lstinline{apply} přijímá tři argumenty. První argument -- objekt typu
\lstinline{InterpreterInterface} slouží ke komunikaci s překladačem jazyka TIL-Script -- v tomto
případě jej nevyužijeme. Druhý argument je seznam argumentů, které obdržela funkce
\lstinline{InvSqrt}. Posledním argumentem je kontext aplikace funkce. Kontext obsahuje pozici
ve zdrojovém kódu, kde k aplikaci funkce došlo. Kontext využíváme pro hlášení chyb -- můžeme
uživateli naší knihovny přesněji říct, kde aplikoval funkci na argumenty, na kterých není
definována.

Konstruktor třídy \lstinline{Nil} přijímá pozici ve zdrojovém kódu, kde tato hodnota vznikla,
seznam hlášení, který opět bude prázdný, a nakonec důvod, proč je výsledkem aplikace funkce hodnota
\lstinline{Nil}. Seznam hlášení by v jazyce Kotlin nebylo třeba explicitně uvádět, neboť by byl
vytvořen implicitním argumentem. Tento seznam slouží k hlášení chyb, které však nemůžou vzniknout
při implementaci funkce v jazyce Java.

Konstruktor třídy \lstinline{Real} přijímá reálné číslo, které daný objekt představuje, pozici
ve zdrojovém kódu, kde byl daný objekt zkonstruován, a (opět prázdný) seznam hlášení.

\subsection{Implementace registrátoru}

Dále musíme implementovat vlastní registrátor -- třídu, jejíž instance nám umožní importovat
námi definovanou funkci. Registrátor musí implementovat rozhraní
\lstinline{SymbolRegistrar}. Rozhraní definuje řadu abstraktních metod -- opět si je můžeme nechat
vygenerovat vývojovým prostředím. Tyto metody nám umožňují registrovat např. struktury, typové
aliasy (\lstinline{TypeDef}), apod. Zde uvedeme pouze definici metody \lstinline{getFunctions()},
jež slouží k registraci funkcí. Zbylé metody vrací pouze prázdný seznam
(\lstinline{java.util.ArrayList}) a neuvádíme je v ukázce za účelem zkrácení zápisu, v reálné
implementaci by funkce pouze vraceli instanci prázného seznamu, nesměly by však chybět.

Metoda \lstinline{getFunctions()} pouze vytvoří seznam obsahující instanci námi vytvořené funkce.

\begin{lstlisting}[caption={Java registrátor}, language=Java]
public class JavaMathRegistrar implements SymbolRegistrar {

  @NotNull
  @Override
  public List<FunctionInterface> getFunctions() {
    return Arrays.asList(
      new InvSqrt()
    );
  }

}
\end{lstlisting}

\subsection{Aplikace \lstinline{InvSqrt} v TIL-Script programu}

Po implementaci a sestavení naší Java knihovny již stačí pouze knihovnu importovat v TIL-Script
programu a funkci aplikovat.

\begin{lstlisting}[caption={Aplikace InvSqrt}, language=Haskell]
Import "class://org.fpeterek.tilscript.javamath.JavaMathRegistrar".

['Println ['InvSqrt '4.0]].
\end{lstlisting}

Následně program spustíme a ujistíme se, že program vypíše očekávanou hodnotu. První řádek výpisu
obsahuje spuštění překladače. Druhý řádek je již výstup programu.

\begin{lstlisting}[caption={Aplikace InvSqrt}, language=Bash]
$ ./bin/tilscript.sh examples/javasqrt.tils
0.5
\end{lstlisting}

\endinput
