\chapter{Uživatelská dokumentace}

Tato kapitola je věnována uživatelské dokumentaci. Uživatelská dokumentace začíná ukázkou několika
TIL-Script programů. Poté následuje návod, jak spustit překladač jazyka TIL-Script a program
přeložit. Dále dokumentace popisuje standardní i matematickou knihovnu. Součástí dokumentace je
například popis funkcí standardní i matematické knihovny. Uživatel tak může při práci s jazykem
TIL-Script konzultovat tuto dokumentaci a vyhledávat si potřebné informace. Na konci dokumentace
se nachází také ukázka implementace TIL-Script knihovny v jazyce Java, příloha práce však obsahuje
také ukázku knihovny psané v jazyce Kotlin.

\section{Ukázka TIL-Script programu}

\subsection{Hello, World!}

V rámci zachování programátorské tradice začneme ukázkou implementace programu
\lstinline{Hello, World!}.

Náš program nejprve začíná komentáři. Zápis komentářů je stejný jako v jazyce Haskell. Obsah
komentářů je překladačem ignorován. Komentáře následuje velmi jednoduchá Kompozice. Kompozicí
aplikujeme funkci \lstinline{Println} na argument -- objekt, který chceme vypsat. Objekt může být
libovolného typu, zde vypisujeme textový řetězec. Funkci \lstinline{Println} a literál textového
řetězce nesmíme zapomenout trivializovat.

\begin{lstlisting}[caption={Program Hello, World! v jazyce TIL-Script}]
-- Toto je komentář
-- Následující řádek vypíše Hello, World!
['Println '"Hello, World!"].
\end{lstlisting}

\subsection{Jednoduchá aritmetika}

Nyní si ukážeme složitější Kompozice, ukázku matematických funkcí, a také přiřazení do proměnné,
abychom nemuseli stejnou kompozici zbytečně provádět vícekrát. Abychom mohli využívat matematické
funkce, nesmíme zapomenout importovat matematickou knihovnu.

\begin{lstlisting}[caption={Aritmetika v jazyce TIL-Script}]
-- Import matematické knihovny
Import "class://org.fpeterek.tilscript.math.Registrar".

-- Aplikace funkce
-- Nesmíme zapomenout, že definičním oborem logaritmu
-- jsou reálná čísla, proto musíme zapsat literál reálného čísla
-- Literály reálných čísel obsahují desetinnou tečku a alepoň jednu
-- číslici před i za desetinnou tečkou
['Log '27.0 '3.0].

-- Výsledek kompozice využijeme jako argument jiné funkce
['Log ['+ '20.0 '7.0] '3.0].

-- Předchozí výsledky jsme však zbytečně zahodili
-- Abychom mohli s výsledkem dále pracovat,
-- uložíme jej do proměnné
-- Alternativně můžeme výsledek vypsat na výstup programu

x -> Real := ['Log ['+ '20.0 '7.0] '3.0].

-- Čísla můžeme sčítat, odčítat, násobit, dělit i porovnávat

-- Vypíše True
['Println ['= ['+ '15 '5] ['- '24 '4]]].

-- Vypíše False
['Println ['= ['* '2 '3] ['/ '42 '6]]].

-- Proměnnou můžeme provést
['Println x].

-- A využít jako argument funkce
['Println ['Cos x]].

-- Na výstup programu můžeme vypsat také konstrukci
-- Zde aplikujeme funkci Print na konstrukci, abychom ji vypsali
-- Využíváme Print, ne Println, abychom nevypsali sekvenci odřádkování
['Print '['Cos x]].

-- Oddělíme konstrukci od výsledku jejího provedení
['Print '": "].

-- A nakonec konstrukci provedeme a výsledek vypíšeme
['Println ['Cos x]].
\end{lstlisting}

\subsection{Abstrakce a tvorba funkcí}

Abstrakce je základním pravidlem jak lambda kalkulu, tak programování. Nyní si abstrakce v jazyce
TIL-Script ukážeme prakticky.

Funkci lze vytvořit provedením uzávěru, nebo pomocí speciální syntaxe pro definici pojmenované
funkce. Uzávěr je konstrukcí, proto jej můžeme využít jako podkonstrukci jiné konstrukce. Definice
pojmenované funkce konstrukcí není. Definicí pojmenované funkce přiřadíme funkci jméno. Kdykoliv
pak potřebujeme funkci zmínit, využijeme k tomu její jméno. Pojmenovanou funkci nesmíme zapomenout
trivializovat.

V ukázce si také zkusíme vytvořit trochu zajímavější funkci. V předchozí ukázce jsme chtěli vypsat
konstrukci i její výsledek. V nynější ukázce si nad tímto výpisem vytvoříme abstrakci. V ukázce
využijeme funkci \lstinline{Progn}. Funkce je podrobněji popsána v dokumentaci funkcí standardní
knihovny, viz \peteref{progn-fn}. Nyní pouze uvedeme, že se jedná o syntaktický cukr
nad kombinátorem $\lambda x y . y$. Je-li alespoň jeden z argumentů \lstinline{Progn} \lstinline{Nil},
pak je nevlastní celá kompozice, jinak funkce \lstinline{Progn} vrací svůj druhý argument. Pokud
obdrží argumentů více, parser kompozici rozepíše na vnořené aplikace binární funkce
\lstinline{Progn}.

\begin{lstlisting}[caption={Funkce a uzávěry}, language=Tilscript]
-- Funkci lze zkonstruovat provedením uzávěru
[\x: Real, y: Real -> Real ['Sqrt ['+ ['* x x] ['* y y]]]].

-- Takto zkonstruovanou funkci lze aplikovat
-- Pro přehlednost uzávěr a argumenty uvádíme na více řádcích
[[\x: Real, y: Real -> Real ['Sqrt ['+ ['* x x] ['* y y]]]]
  '3.0
  '4.0].

-- Pro zpřehlednění můžeme funkci přiřadit proměnné
hypotenuse -> (Real Real Real) :=
  [\x: Real, y: Real -> Real
    ['Sqrt ['+ ['* x x] ['* y y]]]].

-- Jelikož je hypotenuse proměnná, netrivializujeme ji
['Println [hypotenuse '3.0 '4.0]].

-- Nyní si vytvoříme funkci pro výpis konstrukce
-- a výsledku jejího provedení
-- Funkci Progn využijeme, abychom provedli více
-- výpisů na výstup programu
-- Proměnná cons v-konstruuje konstrukci
-- Nejprve vypíše danou konstrukci
-- Za konstrukci poté dopíšeme dvojtečku
-- Nakonec musíme využít dvojí provedení, abychom provedli
-- konstrukci konstruovanou proměnnou cons
Defn PrettyPrint(cons: Construction) -> Any1 :=
  ['Progn
    ['Print cons]
    ['Print '": "]
    ['Println ^2 cons]].

-- Nakonec stačí funkci aplikovat na konstrukci
['PrettyPrint '[hypotenuse '3.0 '4.0]].
\end{lstlisting}

V praxi se klidně může stát, že bude funkce \lstinline{PrettyPrint} aplikována na funkci,
která je $v$-nevlastní pro aktuálně zkoumanou valuaci $v$. Aplikací funkce \lstinline{Println}
na hodnotu \lstinline{Nil} dojde k výpisu \lstinline{Nil} na výstup programu, přesto bude celá
Kompozice $v$-nevlastní. Toto chování je v praxi pravděpodobně žádoucí, chtěli bychom vidět, že naše
Kompozice byla $v$-nevlastní a nezkonstruovala žádnou hodnotu. Jako cvičení si však můžeme napsat
také variaci funkce \lstinline{PrettyPrint}, jež provede zápis na výstup programu pouze pokud
obdržená konstrukce není $v$-nevlastní.

Za tímto účelem musíme vytvořit novou abstrakci nad aplikací funkce \lstinline{Progn}. Abstrakci
vytvoříme uzávěrem. Uzávěr bude konstruovat funkci, která přijímá jeden argument -- výsledek
provedení konstrukce, jež je argumentem \lstinline{PrettyPrint}. Pokud bude tato konstrukce
$v$-nevlastní, bude současně $v$-nevlastní také aplikace naší abstrakce nad \lstinline{Progn}.

\begin{lstlisting}[caption={Funkce a uzávěry}]
Defn PrettyPrint(cons: Construction) -> Any1 :=
  -- Abstrakce nad aplikací Progn
  [[\x: Any1 -> Any1
    ['Progn
      ['Print cons]
      ['Print '": "]
      ['Println x]]]
      -- Argument funkce konstruované uzávěrem
      ^2 cons].
\end{lstlisting}

\subsection{Seznamy}

Další praktický příklad se týká práce se seznamy. Předvedeme, jak idiomaticky pracovat se seznamy
(tvorba, traverzace, apod.). Z příkladu poté snad vyplynou také výhody induktivní implementace
seznamů, jež se využívá ve funkcionálních programovacích jazycích.

Nejprve začneme tvorbou jednoduchého seznamu. Seznam vytvoříme aplikací funkce \lstinline{ListOf}.
Funkce \lstinline{ListOf} slouží jako syntaktický cukr, který nám zjednoduší tvorbu seznamu.

Následně si zkusíme seznam proiterovat a odstranit z něj prvky větší nebo rovné pěti. Začneme proto
tvorbou predikátu, funkce \lstinline{LessThanFive}. Dále vytvoříme rekurzivní funkci
\lstinline{GetSmall}, která vytvoří nový seznam obsahující pouze takové prvky, které jsou menší než
pět. Funkce jako svůj argument obdrží seznam. Zde můžeme vidět využití funkce \lstinline{If}.

Je-li seznam prázdný, vrátíme jej v nezměněné podobě -- z prázdného seznamu již nemáme co
odstraňovat. Argumenty funkce \lstinline{If} jsou vyhodnocovány líně -- je vždy vyhodnocena pouze
jedna podkonstrukce. Pokud by došlo k vyhodnocení obou konstrukcí, došlo by k pokusu k přístupu
prvního prvku seznamu -- prázdný seznam ovšem nemá první prvek. Celá aplikace \lstinline{GetSmall}
by tak byla $v$-nevlastní pro všechny argumenty a ve všech valuacích (jednalo by se o funkci
\textit{degenerovanou}).

Pokud je seznam neprázdný, potřebujeme provést další aplikaci funkce \lstinline{If}. Nejprve
zkontrolujeme, jestli je první prvek seznamu menší než pět. Nezávisle na hodnotě aktuálního prvku --
pomocí funkce \lstinline{Tail} vezmeme seznam bez jeho prvního prvku, a rekurzivně aplikujeme
\lstinline{GetSmall}. Rekurzivní aplikací získáme zbytek seznamu, z něhož již byly odstraněny čísla
větší než čtyři. Jediné, v čem se liší jednotlivé větve podmínky (argumenty funkce \lstinline{If}),
je, zda zachováme první prvek seznamu, nebo ne. Pokud je prvek seznamu menší než pět, pomocí funkce
\lstinline{Cons} vytvoříme nový seznam přidáním prvního prvku původního seznamu na začátek seznamu
vytvořeného rekurzivní aplikací \lstinline{GetSmall}. Pokud je hodnota prvku pět nebo vyšší, vrátíme
pouze výsledek rekurzivní aplikace \lstinline{GetSmall} na zbytek seznamu a první prvek ignorujeme.

Jelikož jsou seznamy neměnné (chceme-li seznam jakkoliv změnit, naší jedinou možností je vytvořit
nový seznam), a protože jsou definovány induktivě (každý seznam je buď prázdný seznam, nebo buňka,
\textit{cons cell}, skládající se z prvního prvku seznamu, a podseznamu reprezentující zbytek
seznamu), jsou operace \lstinline{Cons}, \lstinline{Head}, \lstinline{Tail} (přesněji tedy operace,
které aplikace těchto funkcí představuje), proveditelné v konstantním čase.

Dále budeme chtít projít seznam, a vybrat jen ty prvky, které jsou větší než čtyři. Ihned se nabízí
možnost zkopírovat funkci \lstinline{GetSmall} a jen ji upravit, aby využila jiný predikát. Snad
není třeba uvádět, že tento postup je neideální, neboť v lambda kalkulu, a tedy i Transparentní
intenzionální logice, lze využívat funkce jako argumenty jiných funkcí. Proto zkopírujeme funkci
\lstinline{GetSmall}, novou funkci pojmenujeme \lstinline{Filter}, a přidáme nový argument,
predikát, funkci typu \lstinline{(Bool Int)}. Aplikace funkce \lstinline{GetSmall} nahradíme
rekurzivní aplikací \lstinline{Filter}, a jako místo aplikace \lstinline{LessThanFive} aplikujeme
funkci zkonstruovanou provedením argumentu \lstinline{pred}.

Funkci \lstinline{Filter} můžeme jako predikát předat funkci \lstinline{LessThanFive}, a ověřit,
že aplikace funkce \lstinline{Filter} na seznam a predikát \lstinline{LessThanFive} je procedurálně
izomorfní Kompozicí s procedurou aplikace \lstinline{GetSmall} na ekvivalentní seznam.

Funkci \lstinline{GetBig} poté definujeme pouze jako aplikaci funkce \lstinline{Filter} na seznam
a predikát $\lambda x ['> x '4]$.

Dále se pokusíme napsat funkci, která transformuje jednotlivé prvky seznamu, ale zachová počet
prvků. Takovou funkci tradičně ve funkcionálním programování nazýváme \lstinline{Map}, proto se
tohoto názvosloví budeme nyní držet. Funkce \lstinline{Map} přijímá dva argumenty -- seznam, a
funkci, pomocí které transformujeme jeden prvek seznamu. Nyní nám postačí jen jediná podmínka.
Pokud je seznam prázdný, vrátíme jej, jak jsme jej obdrželi -- není co transformovat. Pokud je seznam
neprázný, aplikujeme funkci reprezentovanou argumentem \lstinline{transform} na první prvek
seznamu, rekurzivně transformujeme zbytek seznamu, a nakonec vytvoříme nový seznam
z transformovaného zbytku a prvního prvku seznamu pomocí funkce \lstinline{Cons}. Poté stačí ověřit
funkčnost funkce \lstinline{Map} například tím, že si spočítáme druhé mocniny čísel v našem seznamu.

Poslední příklad jen ukazuje, že nemusíme definovat pouze seznamy čísel. Lze definovat také seznamy
individuí, funkcí, konstrukcí, apod. Seznamy jsou ovšem homogenní, nemůžou tedy obsahovat objekty
různého typu.

\begin{lstlisting}[caption={Funkce a uzávěry}, language=Tilscript]
numbers -> List(Int) := ['ListOf '1 '6 '2 '5 '3 '4].

Defn LessThanFive(num: Int) -> Bool := ['< num '5].

Defn GetSmall(list: List(Int)) -> List(Int) :=
    ['If ['IsEmpty list]
        list
        ['If ['LessThanFive ['Head list]]
            ['Cons ['Head list] ['GetSmall ['Tail list]]]
            ['GetSmall ['Tail list]]]].

['Println ['GetSmall numbers]].

Defn Filter(list: List(Int), pred: (Bool Int)) -> List(Int) :=
    ['If ['IsEmpty list]
        list
        ['If [pred ['Head list]]
            ['Cons ['Head list] ['Filter ['Tail list] pred]]
            ['Filter ['Tail list] pred]]].

['Println ['Filter numbers 'LessThanFive]].

Defn GetBig(list: List(Int)) -> List(Int) :=
    ['Filter list [\x: Int -> Bool ['> x '4]]].

['Println ['GetBig numbers]].

Defn Map(list: List(Int), transform: (Int Int)) -> List(Int) :=
    ['If ['IsEmpty list]
        list
        ['Cons
            [transform ['Head list]]
            ['Map ['Tail list] transform]]].

['Println ['Map numbers [\x: Int -> Int ['* x x]]]].

Karel, Petr, Adela/Indiv.

['Println ['ListOf 'Karel 'Petr 'Adela]].
\end{lstlisting}

\subsection{N-tice}

\subsection{Intenze}

Nakonec si ještě ukážeme práci s intenzemi.

\section{Překlad programu}

Překladač byl psán pro platformu Java, proto pro spuštění překladače jazyka TIL-Script musíme mít
nainstalované Java prostředí (JRE). Máme-li JRE nainstalované, překladač můžeme spustit ručně, nebo
pomocí přiloženého pomocného skriptu.

Překladač spouštíme vždy z příkazové řádky, neboť pro něj momentálně neexistuje grafické rozhraní.

Při ručním spuštění je třeba manuálně spustit Java prostředí a specifikovat JAR soubor obsahující
kód TIL-Script překladače. Překladači je potřeba předat jako argument název souborů, které chceme
přeložit. Pokud je interpret TIL-Scriptu jediný Java archiv, který načítáme, není třeba specifikovat
tzv. \textit{Main Class}, tedy třídu obsahující statickou metodu \lstinline{void main()} (neboť
specifikace této třídy je součástí souboru \lstinline{manifest} obsaženém v archivu).

\begin{lstlisting}[caption={Spuštění překladače}]
java -jar tilscript.jar script.tils
\end{lstlisting}

Pokud chceme kromě překladače načíst také TIL-Script knihovny, musíme uvést nejen všechny archivy,
jenž potřebuje Java prostředí načíst, ale také hlavní třídu.

\begin{lstlisting}[caption={Spuštění překladače s načtením knihoven}]
java -cp tilscript.jar:libs/math.jar org.fpeterek.tilscript.interpreter.MainKt script.tils
\end{lstlisting}

\subsection{tilscript.sh}

Nejjednodušší způsob, jak překladač jazyka TIL-Script spustit, je využít pomocný skript
\lstinline{tilscript.sh}. Skript \lstinline{tilscript.sh} využívá pouze funkcionalitu definovanou
standardem POSIX, proto by tento skript měl fungovat korektně na všech operačních systémech
splňujících standard POSIX. Dále se standardu POSIX musí držet také shell, který bude tento pomocný
skript interpretovat\footnote{Můžeme tedy používat například ZSH nebo Bash. Naopak shell Fish není
kompatibilní se standardem POSIX, proto skript nebude fungovat korektně}.

Skript \lstinline{tilscript.sh} předpokládá, že se nachází ve stejné složce jako soubor
\lstinline{tilscript.jar}, tedy archiv obsahující přeložený kód překladače. Dále tento skript
předpokládá existenci adresáře \lstinline{libs/}, opět ve stejné složce, jako skript samotný.
Skript při spuštění automaticky načte všechny Java archivy ve složce \lstinline{libs/}, spustí
Java prostředí, zajistí načtení všech knihoven i TIL-Script překladače a korektně uvede hlavní
třídu překladače. Všechny argumenty, které skript obdrží, poté automaticky předá TIL-Script
překladači.

\begin{lstlisting}[caption={Spuštění překladače za využití pomocného skriptu}]
./tilscript.sh script.tils
\end{lstlisting}

\section{Standardní knihovna}

Standardní knihovna jazyka TIL-Script obsahuje základní funkce pro práci s objekty Transparentní
intenzionální logiky. Dále obsahuje definice atomických typů a tří proměnných. Z důvodu náročnosti
implementace některým funkcím chybí implementace, proto je můžeme pouze zmínit, nemůžeme však
provést jejich aplikaci.

Nakonec je třeba uvést, že současný stav nemusí reprezentovat také konečný stav standardní knihovny.
Na základě zpětné vazby uživatelů lze standardní knihovnu v budoucnu rozšiřovat.

\subsection{Funkce}

\subsubsection{Deklarace}

Zde uvedeným funkcím chybí implementace z důvodu její náročnosti a časové složitosti. Představme si
například všeobecný kvantifikátor. Logickou pravdivost řady tvrzení či úsudků lze dokázat například
pomocí důkazových kalkulů (rezoluční metoda, přirozená dedukce). Tyto metody dokazování jsou ovšem
čistě syntaktické, nedokáží tedy dokázat pravdivost tvrzení jako například $\forall x[P(x)]$. V takových
případech bychom se museli uchýlit k sémantické analýze predikátu $P$.
Predikát ovšem může být netriviální a jeho analýza velmi složitá. Iterace přes celý obor hodnot
predikátu je naopak nepraktická nebo nemožná. Pokud by predikát $P$ byla funkce typu $(o\tau)$
(nezapomeňme, že v Transparentní intenzionální logice pracujeme pouze s funkcemi), iterovat přes
obor hodnot by bylo nemožné, neboť množina reálných čísel je nespočetná. Množina všech validních
hodnot 64-bitového čísla s plovoucí řádovou čárkou spočetná je, proto je možné přes tato čísla
iterovat, není to však praktické, neboť by výpočet nemusel v skončit v rozumném čase.

\subsubsection*{Funkce: \lstinline|ForAll|}
Typ: \lstinline|(Bool (Bool Any1))|

Všeobecný kvantifikátor

\subsubsection*{Funkce: \lstinline|Exist|}
Typ: \lstinline|(Bool (Bool Any1))|

Existenční kvantifikátor

\subsubsection*{Funkce: \lstinline|Sing|}
Typ: \lstinline|(Bool (Bool Any1))|

Singularizátor

\subsubsection*{Funkce: \lstinline|Every|}
Typ: \lstinline|((Bool (Bool Any1)) (Bool Any1))|

Omezený kvantifikátor

\subsubsection*{Funkce: \lstinline|Some|}
Typ: \lstinline|((Bool (Bool Any1)) (Bool Any1))|

Omezený kvantifikátor

\subsubsection*{Funkce: \lstinline|No|}
Typ: \lstinline|((Bool (Bool Any1)) (Bool Any1))|

Omezený kvantifikátor

\subsubsection*{Funkce: \lstinline|Sub|}
Typ: \lstinline|(Construction Construction Construction Construction)|

Funkce \textit{Sub} substituční metody

\subsubsection*{Funkce: \lstinline|TrueC|}
Typ: \lstinline|(Bool Construction)|

Třída konstrukcí pravdivých ve všech valuacích $v$.

\subsubsection*{Funkce: \lstinline|FalseC|}
Typ: \lstinline|(Bool Construction)|

Třída konstrukcí nepravdivých ve všech valuacích $v$.

\subsubsection*{Funkce: \lstinline|ImproperC|}
Typ: \lstinline|(Bool Construction)|

Třída konstrukcí $v$-nevlastních pro všechny valuace $v$.

\subsubsection*{Funkce: \lstinline|TrueC|}
Typ: \lstinline|(Bool ((Bool Time) World))|

Třída propozic pravdivých ve všech valuacích $v$.

\subsubsection*{Funkce: \lstinline|FalseC|}
Typ: \lstinline|(Bool ((Bool Time) World))|

Třída propozic nepravdivých ve všech valuacích $v$.

\subsubsection*{Funkce: \lstinline|TrueC|}
Typ: \lstinline|(Bool ((Bool Time) World))|

Třída propozic $v$-nevlastních ve všech valuacích $v$.

\subsubsection{Definice}

Následující funkce již jsou korektně definovány a lze provést jejich aplikaci na argumenty. Ke každé
funkci je přiložena ukázka jejího využití.

\subsubsection*{Funkce: \lstinline|ListOf|}

\lstinline{ListOf} slouží pouze jako syntaktický cukr pro tvorbu seznamů. \lstinline{ListOf}
aplikujeme na alespoň jeden argument, počet argumentů je ale shora neomezený. Jediným omezením je,
že všechny argumenty musí být stejného typu. Parser jazyka TIL-Script poté aplikaci
\lstinline{ListOf} převede na korektní sestavení seznamu pomocí funkce \lstinline{ListOfOne} a
funkcí \lstinline{Cons}.


\begin{lstlisting}[caption={Ukázka využití ListOf}]
-- Následující dvě konstrukce jsou ekvivalentní
['ListOf '1 '2 '3 '4].
['Cons '1 ['Cons '2 ['Cons '3 ['ListOfOne '4]]]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|ListOfOne|}
Typ: \lstinline{(List(Any1) Any1)}

Funkce \lstinline{ListOfOne} vytvoří seznam obsahující jediný prvek.

\begin{lstlisting}[caption={Ukázka využití ListOfOne}]
['ListOfOne 'Pi].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|Cons|}
Typ: \lstinline{(List(Any1) Any1 List(Any1))}

Funkce \lstinline{Cons} vytvoří nový seznam vložením prvku na začátek již existujícího seznamu.
Jelikož jsou seznamy definovány induktivně, a zároveň jsou neměnné, není třeba již existující seznam
kopírovat. Proto lze tuto operaci provést v konstantním čase.

\begin{lstlisting}[caption={Ukázka využití Cons}]
['Cons 'Pi ['LisOf '1 '2 '3]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|Head|}
Typ: \lstinline{(Any1 List(Any1))}

Funkce \lstinline{Head} vrátí první prvek seznamu. Seznam musí být neprázdný, v opačném případě
funkce nevrací nic (vrací \lstinline{Nil}).

\begin{lstlisting}[caption={Ukázka využití Head}]
['Head ['ListOf '1 '2 '3]]. -- Konstruuje 1
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|Tail|}
Typ: \lstinline{(List(Any1) List(Any1))}

Funkce \lstinline{Tail} vrátí seznam bez jeho prvního prvku. Funkce je nedefinovaná pro prázdné
seznamy.

\begin{lstlisting}[caption={Ukázka využití Head}]
['Tail ['ListOf '1 '2 '3]]. -- Konstruuje seznam [2, 3]
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|IsEmpty|}
Typ: \lstinline{(Bool List(Any1))}

Aplikací \lstinline{IsEmpty} na prázdný seznam získáme hodnotu \lstinline{True}. Aplikací
na neprázdný seznam získáme \lstinline{False}.

\begin{lstlisting}[caption={Ukázka využití IsEmpty}]
['IsEmpty ['ListOf '1 '2 '3]]. -- False
['IsEmpty ['Tail ['ListOfOne '1]]]. -- True
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|EmptyListOf|}
Typ: \lstinline{(List(Any1) Type)}

Funkce \lstinline{EmptyListOf} jako svůj jediný vstup přijímá objekt typu \lstinline{Type}.
Výsledkem aplikace na typ je poté prázdný seznam objektů specifikovaného typu.

\begin{lstlisting}[caption={Ukázka využití EmptyListOf}]
['IsEmptyOf 'Int].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline|Print|, \lstinline{Println}}
Typ: \lstinline{(Any1 Any1)}

Funkce \lstinline{Print}, \lstinline{Println} zajistí výpis svého argumentu na standardní výstup
programu a poté vrátí svůj jediný argument. Funkce \lstinline{Println} vypíše také oddělovač řádků
(v systému GNU/Linux znak LF, v systému Windows sekvenci CRLF). Funkce \lstinline{Print} tento
oddělovač nevypisuje.

\begin{lstlisting}[caption={Ukázka využití Print, Println}]
['Println '['+ '1 '2]]. -- Vypíše konstrukci ['+ '1 '2]
['Print ['+ '1 '2]]. -- Vypíše konstrukci ['+ '1 '2]
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{If}}
Typ: \lstinline{(Any1 Bool Any1 Any1)}

Funkce \lstinline{If} je, narozdíl od všech ostatních funkcí, prováděna líně. Funkce \lstinline{If}
přijímá tři argumenty. První argument je objekt typu \lstinline{Bool}. Druhým argumentem je hodnota,
kterou funkce vrátí, je-li první argument \lstinline{True}. Jinak funkce \lstinline{If} vrátí svůj
druhý argument. Konstrukce, která konstruuje argument funkce \lstinline{If}, je ovšem provedena až
poté, co překladač zkontroluje hodnotu prvního argumentu, aby nedošlo ke zbytečnému provedení
konstrukce a následnému zahození výsledku.

\begin{lstlisting}[caption={Ukázka využití If}]
['If ['> x y]
    ['Println '"x is greater than y"]
    ['Println '"y is greater than or equal to x"]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Cond}}

\lstinline{Cond} slouží pouze jako syntaktický cukr pro funkci \lstinline{If}. \lstinline{Cond} tedy
není funkcí sama o sobě, překladačem je ovšem při procesu tvorby AST přeložena na sérii vnořených
aplikací funkce \lstinline{If}.

Máme-li pouze jednu podmínku se dvěma větvemi, \textit{if} a \textit{else}, je využití funkce
\lstinline{If} jednoduché a čitelné. Máme-li však větví více, musíme aplikace funkce \lstinline{If}
zanořit -- větví \textit{else} tak musí být další aplikace \lstinline{If}.

Syntaktický cukr \lstinline{Cond} nám umožňuje zjednodušit zápis funkce \lstinline{If} a vyhnout
se zanořování. \lstinline{Cond} přijímá nespecifikovaný, avšak sudý počet argumentů. Lichým
argumentem je vždy podmínka. Sudým argumentem je poté konstrukce, která se provede, je-li podmínka
pravdivá. Překladač během překladu přeloží aplikaci \lstinline{Cond} na zanořené aplikace funkce
\lstinline{If}. Podmínky se tedy nevyhodnocují všechny najednou, ale jedna po druhé, dokud není
nalezena první pravdivá podmínka. Není-li pravdivá ani jedna podmínka, \lstinline{Cond} vrací
\lstinline{Nil}.

\begin{lstlisting}[caption={Ukázka využití Cond}]
['Cond
    ['= x '2] ['Log2 y]
    ['= x '10] ['Log10 y]
    'True ['Ln y]]. -- catch-all podmínka
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Progn}}\label{progn-fn}
Typ: \lstinline{(Any2 Any1 Any2)}

Funkce \lstinline{Progn} přijímá dva argumenty. První argument ignoruje, druhý argument vrátí, jak
jej dostala. Funkce \lstinline{Progn} je tedy ekvivalentem funkce \textit{False} lambda kalkulu
($\lambda x \lambda y . y$, případně $\lambda x, y: y$ v TIL). Díky principu kompozicionality je aplikace
\lstinline{Progn} $v$-nevlastní, neobdrží-li první argument. V takovém případě tedy vůbec nedojde
k vyhodnocení druhého argumentu.

Funkci \lstinline{Progn} využijeme například při výpisu např. do souboru nebo na standardní výstup.
Pro analýzu přirozeného jazyka většinou není potřeba, kódovat přirozená čísla pomocí Churchova
kódování v Transparentní intenzionální logice nepotřebujeme.

Funkce \lstinline{Progn} je binární funkcí, existuje pro ni ovšem podobný syntaktický cukr, jako pro
\lstinline{Cond} nebo \lstinline{ListOf}. Předáme-li funkci \lstinline{Progn} více než dva
argumenty, překladač aplikaci \lstinline{Progn} na více argumentů rozepíše na vnořené aplikace
binární funkce \lstinline{Progn}. Narozdíl od \lstinline{Cond}, \lstinline{Progn} je tedy
skutečnou funkcí.

Název \lstinline{Progn} je převzat z jazyka Lisp.

\begin{lstlisting}[caption={Ukázka využití Progn}]
-- Vypíše 'x + y = ' a součet x a y
-- Vrátí součet x+y, protože Println vrátí svůj argument
['Progn
    ['Print '"x + y = "]
    ['Println ['+ x y]]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Tr}}
Typ: \lstinline{(Construction Any1)}

Trivializuje svůj argument.

\begin{lstlisting}[caption={Ukázka využití Tr}]
['Tr ['+ '1 '2]]. -- Kompozice konstruuje '3
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{TypeOf}}
Typ: \lstinline{(Type Any1)}

Vrátí typ svého argumentu. Může být užitečné například v typově polymorfních funkcích,
potřebujeme-li provést rozhodnutí na základě typu argumentu.

\begin{lstlisting}[caption={Ukázka využití TypeOf}]
-- Volba funkce na základě typu argumentu typově polymorfní funkce
\x: Any1 -> Any1 [['If ['= ['TypeOf x] 'Int] 'DiscreteLog 'Log10] x].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{IsNil}}
Typ: \lstinline{(Bool Any1)}

Vrátí \lstinline{True}, neobdrží-li žádný argument (tedy je-li argumentem \lstinline{Nil}). Tato
funkce porušuje princip kompozicionality, je ovšem potřeba např. k ošetření chyb.

\begin{lstlisting}[caption={Ukázka využití IsNil}]
x -> Real = ['/ a b].
['If ['IsNil x]
    -- Vypíšeme chybu a ukončíme program
    ['Progn
        ['Println '"Program obdržel nesprávný vstup"]
        ['Exit '-1]]
    -- Program obdržel validní vstup, hodnota 1 bude ignorována
    '1].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Exit}}

Aplikací \lstinline{Exit} ukončíme překlad programu. Argument funkce určuje návratovou hodnotu
programu.

\begin{lstlisting}[caption={Ukázka využití Exit}]
x -> Real = ['/ a b].
['If ['IsNil x]
    -- Vypíšeme chybu a ukončíme program
    ['Progn
        ['Println '"Program obdržel nesprávný vstup"]
        ['Exit '-1]]
    -- Program obdržel validní vstup, hodnota 1 bude ignorována
    '1].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{RandomInt}}
Typ: \lstinline{(Int DeviceState)}

Funkce \lstinline{RandomInt} vrací náhodné celé číslo v intervalu $\bigl \langle 0; 2^{64}-1 \bigr \rangle$.

\begin{lstlisting}[caption={Ukázka využití RandomInt}]
['RandomInt deviceState].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Random}}
Typ: \lstinline{(Real DeviceState)}

Funkce \lstinline{Random} vrací náhodné reálné číslo v intervalu $\bigl \langle 0; 1 \bigr \rangle$.

\begin{lstlisting}[caption={Ukázka využití Random}]
['* ['Random deviceState] '100]. -- náhodné číslo v rozsahu 0-100
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Not}}
Typ: \lstinline{(Bool Bool)}

Logická negace.

\begin{lstlisting}[caption={Ukázka využití Not}]
['Not ['= x y]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{And}}
Typ: \lstinline{(Bool Bool Bool)}

Logická konjunkce.

\begin{lstlisting}[caption={Ukázka využití And}]
[And ['= x y] ['= x z]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Or}}
Typ: \lstinline{(Bool Bool Bool)}

Logická disjunkce.

\begin{lstlisting}[caption={Ukázka využití Or}]
[Or ['= x y] ['= x z]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Implies}}
Typ: \lstinline{(Bool Bool Bool)}

Implikace.

\begin{lstlisting}[caption={Ukázka využití Implies}]
['Implies ['And ['= x y] ['= x z]] ['= y z]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{OneTuple}}
Typ: \lstinline{(Tuple(Any1) Any1)}

Vytvoří n-tici obsahující právě jeden prvek -- obdržený argument. Lze využít například při rekurzivní
tvorbě n-tice.

\begin{lstlisting}[caption={Ukázka využití OneTuple}]
['OneTuple '1].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{MkTuple}}

\lstinline{MkTuple} slouží jako syntaktický cukr pro tvorbu n-tic. \lstinline{MkTuple} přijímá
nespecifikovaný počet argumentů, překladačem je poté přeložena na aplikaci \lstinline{OneTuple}
a následné vložení prvků na začátek n-tice.

\begin{lstlisting}[caption={Ukázka využití OneTuple}]
['MkTuple '1 '3.5 'True].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{PrependToTuple}}
Typ: \lstinline{(Any1 Any2 Any3)}

\lstinline{PrependToTuple} přijímá dva argumenty. Prvním argumentem je libovolná hodnota. Druhý
argument musí být vždy n-tice. \lstinline{PrependToTuple} vytvoří novou (n+1) vložením prvního
argumentu na začátek n-tice specifikované druhým argumentem.

\begin{lstlisting}[caption={Ukázka využití PrependToTuple}]
['PrependToTuple '4 ['MkTuple '1 '3.5 'True]]. -- Vytvoří n-tici (4, 1, 3.5, True)
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Get}}
Typ: \lstinline{(Any1 Any2 Int)}

Funkce \lstinline{Get} umožňuje získat prvek n-tice na požadované pozici. Prvním argumentem je
n-tice, druhým je index prvku. Prvky indexujeme od nuly. Funkce \lstinline{Get} je nedefinovaná,
je-li index větší nebo roven velikosti n-tice.

\begin{lstlisting}[caption={Ukázka využití Get}]
['Get '1 ['MkTuple 'E 'Pi]]. -- Pi
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{TupleLen}}
Typ: \lstinline{(Int Any1)}

Funkce \lstinline{TupleLen} vrátí délku n-tice. Využití funkce je převážně v typově polymorfních
funkcích, neboť není-li funkce typově polymorfní, museli jsme typ explicitně uvést, a tedy délku
n-tice známe. Argumentem musí být n-tice, funkce je typově polymorfní proto, aby argumentem mohly
být n-tice libovolné délky.

\begin{lstlisting}[caption={Ukázka využití TupleLen}]
-- vynásobíme první prvek n-tice délkou n-tice
[\x: Any1 -> Int ['* ['TupleLen x] ['Get x '0]]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{TupleLen}}
Typ: \lstinline{(Int Any1)}

Funkce \lstinline{TupleLen} vrátí délku n-tice. Využití funkce je převážně v typově polymorfních
funkcích, neboť není-li funkce typově polymorfní, museli jsme typ explicitně uvést, a tedy délku
n-tice známe. Argumentem musí být n-tice, funkce je typově polymorfní proto, aby argumentem mohly
být n-tice libovolné délky.

\begin{lstlisting}[caption={Ukázka využití TupleLen}]
-- vynásobíme první prvek n-tice délkou n-tice
[\x: Any1 -> Int ['* ['TupleLen x] ['Get x '0]]].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Char}}
Typ: \lstinline{(Text Text Int)}

Funkce \lstinline{Char} vrátí znak textového řetězce na požadované pozici. Prvky indexujeme od nuly.
Funkce \lstinline{Char} je nedefinovaná, je-li index větší nebo roven velikosti řetězce.


\begin{lstlisting}[caption={Ukázka využití Char}]
['Char '"TIL" '1]. -- "I"
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{CatS}}
Typ: \lstinline{(Text Text Text)}

Funkce \lstinline{CatS} spojí dva textové řetězce.

\begin{lstlisting}[caption={Ukázka využití Char}]
-- Kompozice konstruuje řetězec "Transparentní intenzionální logika"
['CatS '"Transparentní intenzionální" '" logika"].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{HeadS}}
Typ: \lstinline{(Text Text)}

Funkce \lstinline{HeadS} vrátí první znak řetězce. Funkce je nedefinovaná pro prázdné řetězce.

\begin{lstlisting}[caption={Ukázka využití HeadS}]
['HeadS '"TIL"]. -- "T"
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{TailS}}
Typ: \lstinline{(Text Text)}

Funkce \lstinline{HeadS} vrátí řetězec bez prvního znaku. Funkce je nedefinovaná pro prázdné
řetězce.

\begin{lstlisting}[caption={Ukázka využití TailS}]
[TailS '"TIL"]. -- "IL"
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{LenS}}
Typ: \lstinline{(Int Text)}

Funkce \lstinline{LenS} vrátí délku textového řetězce.

\begin{lstlisting}[caption={Ukázka využití LenS}]
[LenS '"TIL"]. -- 3
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{IsBefore}, \lstinline{IsBeforeOrEq}, \lstinline{IsAfter},
  \lstinline{IsAfterOrEq}}
Typ: \lstinline{(Bool Time)}

Funkce slouží k porovnávání časových okamžiků. Pro obyčejnou rovnost lze využít funkci
\lstinline{=}.

\begin{lstlisting}[caption={Ukázka porovnávání časových okamžiků}]
['IsBefore t1 t2].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Now}}
Typ: \lstinline{(Time DeviceState)}

Funkce \lstinline{Now} vrátí aktuální systémový čas.

\begin{lstlisting}[caption={Ukázka využití Now}]
[['PrezidentCR ['Now deviceState]] w].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{IntToText},
\lstinline{RealToText},
\lstinline{IntToTime},
\lstinline{TextToInt},
\lstinline{TextToReal},
\lstinline{TimeToInt},
\lstinline{IntToReal},
\lstinline{RealToInt}
}

Funkce slouží k převodu mezi typy. Při převodu z reálných čísel na čísla celá dochází k ořezání
čísla (zaokrouhlení směrem k nule).

\begin{lstlisting}[caption={Ukázka využití konverzí}]
['Log ['IntToReal ['+ '2 '3]]].
['CatS '"Log 10 = " ['RealToText ['Log '10]]].
\end{lstlisting}

\subsubsection*{Funkce:
\lstinline{IsVariable},
\lstinline{IsComposition},
\lstinline{IsClosure},
\lstinline{IsExecution},
\lstinline{IsFunction},
\lstinline{IsTrivialization},
\lstinline{IsSymbol},
\lstinline{IsList},
\lstinline{IsValue},
\lstinline{IsTuple},
\lstinline{IsConstruction},
\lstinline{IsStruct}
}

Typ: \lstinline{(Bool Any1)}

Tyto funkce umožňují ověřit, zda je argument konkrétní hodnotou (\lstinline{IsValue}), symbolickou
hodnotou (\lstinline{IsSymbol}), seznamem, n-ticí, strukturou nebo konstrukcí. Také nám umožňují
určit, o jaký typ konstrukce se jedná.

\begin{lstlisting}[caption={Ukázka využití IsSymbol}]
[\x: Int -> Int
    ['If ['IsSymbol x]
        Nil -- neumíme umocnit symbolickou hodnotu
        ['* x x]]]. -- konkrétní hodnotu umocníme
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{NilAt}}\label{nilat-fn}
Typ: \lstinline{(Int Text Tuple(Int Int Text))}

Funkce \lstinline{NilAt} je nedefinována na všech argumentech. Funkce umožňuje zkonstruovat hodnotu
\lstinline{Nil}. \lstinline{Nil} jde také zmínit přímo, \lstinline{NilAt} nám ovšem umožňuje vnitřní
reprezentaci \lstinline{Nil} obohatit také o důvod, proč byla konstrukce $v$-nevlastní, a pozici,
kde byla zavolána funkce, jež \lstinline{Nil} vrátila. Tímto způsobem můžeme dosáhnout lepšího
hlášení chyb.

Argumentem funkce je důvod, proč byla vrácena hodnota \lstinline{Nil}, a pozice, kde došlo
k aplikaci funkci na argumenty, na kterých není definována. Často zde budeme chtít použít proměnnou
\lstinline{callsite}, viz \peteref{callsite-var}.

Ukázka je schválně jednoduchá, logaritmus v matematické knihovně tuto situaci řeší sám, v praxi tedy
není třeba kontrolovat argument logaritmu manuálně. Proměnná \lstinline{callsite} konstruuje
pozici ve zdrojovém kódu, kde došlo k aplikaci funkce konstruované uzávěrem.

\begin{lstlisting}[caption={Ukázka využití NilAt}]
[\x: Real -> Real
    ['If ['Not ['> x 0.0]]
        ['NilAt '"Argument logaritmu musí být kladný" 'callsite]
        ['Log x]]].
\end{lstlisting}

%TODO: Continue if necessary

\subsection{Typy}

Standardní knihovna jazyka TIL-Script definuje atomické typy popsané v kapitole
\peteref{tilscript-chapter}, tedy typy
\lstinline{Bool}, \lstinline{Type}, \lstinline{Int}, \lstinline{Text}, \lstinline{Indiv},
\lstinline{Real}, \lstinline{Time}, \lstinline{World}, \lstinline{DeviceState}.

Dále definuje seznamy a n-tice. Žádné struktury standardní knihovna nedefinuje.

\subsection{Proměnné}

Standardní knihovna definuje pouze tři proměnné.

\subsubsection{\lstinline{w -> World}}

Proměnná \lstinline{w} označuje současný svět. Objekty typu \lstinline{World} nemají žádnou
inherentní hodnotu, využívají se hlavně k označení intenzí. Proměnná \lstinline{w} proto existuje,
aby si ji uživatel nemusel zbytečně vytvářet sám.

\subsubsection{\lstinline{deviceState -> DeviceState}}

Proměnná \lstinline{deviceState} existuje ze stejného důvodu, jako proměnná \lstinline{w}. Objekty
typu \lstinline{DeviceState} nemají žádnou skutečnou hodnotu a jsou využívány pro označení funkcí,
jejichž hodnota závisí na stavu zařízení, na němž je program spuštěn.

\subsubsection{\lstinline{callsite -> Tuple(Text Int Int)}}\label{callsite-var}

Proměnná \lstinline{callsite} je automaticky vytvářená proměnná. Proměnná \lstinline{callsite}
je vytvořena při aplikaci funkce, a obsahuje pozici ve zdrojovém kódu, kde byla aplikace funkce
provedena. Proměnná slouží především k umožnění lepšího hlášení chyb.

Proměnná slouží převážně jako argument funkce \lstinline{NilAt}, viz \peteref{nilat-fn}.

\section{Matematická knihovna}

Matematická knihovna slouží také jako ukázka tvorby TIL-Script knihoven v jazycích kompilovaných
do JVM bytekódu, nebo jako test importu jmen z Java archivů. Přesto obsahuje několik užitečných
definic. Narozdíl od standardní knihovny, všechny funkce matematické knihovny jsou korektně
definované, a lze tedy provést jejich aplikaci na argumenty.

\subsection{Funkce}

\subsubsection*{Funkce: \lstinline{Sin}}
Typ: \lstinline{(Real Real)}

Funkce sinus. Kromě konkrétních hodnot přijímá také symbolickou hodnotu \lstinline{Pi/Real}.

\begin{lstlisting}[caption={Ukázka využití Sin}]
['Sin 'Pi]. -- 0
['Sin ['/ '3.14159 '2.0]]. -- přibližně 1
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Asin}}
Typ: \lstinline{(Real Real)}

Inverzní funkce k funkci sinus.

\begin{lstlisting}[caption={Ukázka využití Asin}]
['Asin '0.5].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Cos}}
Typ: \lstinline{(Real Real)}

Funkce cosinus. Kromě konkrétních hodnot přijímá také symbolickou hodnotu \lstinline{Pi/Real}.

\begin{lstlisting}[caption={Ukázka využití Cos}]
['Cos 'Pi]. -- -1
['Cos ['/ '3.14159 '2.0]]. -- přibližně 0
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Acos}}
Typ: \lstinline{(Real Real)}

Inverzní funkce k funkci kosinus.

\begin{lstlisting}[caption={Ukázka využití Acos}]
['Acos '0.5].
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Tan}}
Typ: \lstinline{(Real Real)}

Funkce tangens. Kromě konkrétních hodnot přijímá také symbolickou hodnotu \lstinline{Pi/Real}.

\begin{lstlisting}[caption={Ukázka využití Tan}]
['Tan 'Pi]. -- 0
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Ln, Log2, Log10}}
Typ: \lstinline{(Real Real)}

Přirozený logaritmus, logaritmus o základu dvě a logaritmus o základu 10. Přirozený logaritmus
přijímá rovněž symbolickou hodnotu \lstinline{E/Real}.

\begin{lstlisting}[caption={Ukázka využití Ln, Log2, Log10}]
['Ln ['* '2.71828 '2.71828]]. -- Přibližně 2
['Log2 '1024]. -- 10
['Log10 '1000]. -- 3
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Log}}
Typ: \lstinline{(Real Real Real)}

Logaritmus o libovolném základu. Prvním argumentem je číslo, jehož logaritmus chceme spočítat,
druhým argumentem je základ logaritmu.

\begin{lstlisting}[caption={Ukázka využití Log}]
['Log '27.0 '3.0]. -- 3
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Round}}
Typ: \lstinline{(Real Real)}

Funkce \lstinline{Round} umožňuje zaokrouhlit reálné číslo na jednotky.

\begin{lstlisting}[caption={Ukázka využití Round}]
['Round '3.2]. -- 3
['Round '3.7]. -- 4
\end{lstlisting}

\subsubsection*{Funkce: \lstinline{Sqrt}}
Typ: \lstinline{(Real Real)}

Funkce \lstinline{Sqrt} vrátí druhou odmocninu svého argumentu.

\begin{lstlisting}[caption={Ukázka využití Round}]
['Round '3.2]. -- 3
['Round '3.7]. -- 4
\end{lstlisting}

\subsection{Symbolické hodnoty}

\subsubsection*{Hodnota \lstinline{Pi/Real}}

Hodnota \lstinline{Pi} nám umožňuje symbolicky zmínit číslo $\pi$, viz \peteref{symbolic-values}.

\begin{lstlisting}[caption={Ukázka využití Pi}]
['Sin 'Pi].
\end{lstlisting}

\subsubsection*{Hodnota \lstinline{E/Real}}

Hodnota \lstinline{E} nám umožňuje symbolicky zmínit Eulerovo číslo $e$,
viz \peteref{symbolic-values}.

\begin{lstlisting}[caption={Ukázka využití E}]
['Ln 'E].
\end{lstlisting}

\subsection{Proměnné}

\subsubsection*{Proměnná \lstinline{pi -> Real}}

Proměnná \lstinline{pi -> Real} aproximuje číslo $\pi$ s přesností na 15 desetinných míst.

\begin{lstlisting}[caption={Ukázka využití proměnné pi}]
['* pi '2]. -- přibližně 6.28
\end{lstlisting}

\subsubsection*{Proměnná \lstinline{e -> Real}}

Proměnná \lstinline{e -> Real} aproximuje Eulerovo číslo s přesností na 15 desetinných míst.

\begin{lstlisting}[caption={Ukázka využití proměnné e}]
['Ln ['* e ['* e e]]]. -- 3
\end{lstlisting}

\section{Implementace knihovny}

Nyní si ukážeme, jak implementovat vlastní TIL-Script knihovnu v jazyce Java. Ukázku implementace
v jazyce Kotlin přiložíme za účelem porovnávání těchto dvou jazyků v příloze. V praxi lze využít
libovolný jazyk kompilovaný pro platformu JVM, nejen Javu nebo Kotlin. Implementovat budeme funkci
\lstinline{InvSqrt/(Real Real)}, tedy převrácenou hodnotu druhé odmocniny.

\subsection{Implementace funkce}

Začneme vytvořením třídy \lstinline{InvSqrt}. Tato třída musí být potomkem třídy
\lstinline{DefaultFunction}, abychom ji mohli použít jako TIL-Script funkci.

\begin{lstlisting}[caption={Třída InvSqrt}, language=Java]
public class InvSqrt extends DefaultFunction {

}
\end{lstlisting}

Následně musíme implementovat konstruktor třídy \lstinline{InvSqrt}. V konstruktoru musíme zavolat
konstruktor předka -- třídy \lstinline{DefaultFunction}. Konstruktor \lstinline{DefaultFunction}
přijímá tři argumenty.

Prvním je jméno funkce -- tímto jménem budeme funkci označovat v jazyce TIL-Script. Na jméně třídy,
která danou funkci reprezentuje, nezáleží, kvůli přehlednosti je však lepší třídu pojmenovat podle
názvu funkce.

Druhým argumentem je obor hodnot -- typ objektu, který funkce vrátí. Abychom si zkrátili zápis,
vytváříme v kódu statickou proměnnou \lstinline{real}.

Třetím argumentem je seznam proměnných -- argumentů funkce. Zde nám postačí jeden argument. Opět
vytvoříme pomocnou proměnnou, tentokrát pojmenovanou \lstinline{arg}. Konstruktor třídy
\lstinline{Variable} přijímá pět argumentů. Prvním je název proměnné. Druhým argumentem je pozice
ve zdrojovém kódu -- tento argument se využívá v parseru jazyka TIL-Script a využívá se k hlášení
chyb. Jelikož je funkce implementovaná v Javě, ne v jazyce TIL-Script, nastavíme pozici na hodnotu,
která značí, že je pozice neznámá. Třetí argument konstruktoru určuje typ proměnné. Čtvrtým
argumentem je seznam chyb hlášených při definici proměnné -- jelikož nechceme zbytečně hlásit chyby
pro vlastní proměnnou, vytvoříme prázdný seznam. Posledním argumentem je hodnota proměnné. Jelikož
se ale jedná o argument funkce, není potřeba žádnou hodnotu dodávat. Při aplikaci funkce se vždy
danému argumentu nastaví korektní hodnota. Nakonec tedy vytvoříme seznam obsahující tento jeden
argument.

\begin{lstlisting}[caption={Konstruktor InvSqrt}, language=Java]

  private static AtomicType real = Primitives.INSTANCE.getReal();

  private static Variable arg = new Variable(
    "x",
    new SrcPosition(-1, -1, ""),
    real,
    new ArrayList<>(),
    null
  );

  public InvSqrt() {
    super(
      "InvSqrt",
      real,
      Collections.singletonList(arg)
      );
  }
\end{lstlisting}

Nakonec musíme naprogramovat sémantiku funkce \lstinline{InvSqrt}. Za tímto účelem musíme vytvořit
metodu \lstinline{apply}. Jelikož přepisujeme zděděnou abstraktní metodu, můžeme si ji nechat
vygenerovat vývojovým prostředím nebo jazykovým serverem.

Jakmile máme vygenerovanou hlavičku funkce, stačí funkci naprogramovat. Funkce přijímá pouze jeden
argument, proto si tento argument uložíme do pomocné proměnné, abychom nemuseli při každém
přístupu k argumentu indexovat seznam argumentů.

Následně se ujistíme, že je argument Java objekt typu \lstinline{Real}. Díky typové kontroly víme,
že argument bude reálné číslo, pouze nevíme, zda se jedná o konkrétní číslo (Java objekt typu
\lstinline{Real} reprezentující reálná čísla), nebo o symbolickou hodnotu (Java objekt typu
\lstinline{Symbol}). Pokud argumentem není konkrétní hodnota, bohužel nevíme, jakou hodnotu
potřebujeme odmocnit.

Následně potřebujeme získat hodnotu argumentu jako proměnnou typu \lstinline{double}, abychom
mohli provádět matematické operace v jazyku Java.

Dále se musíme ujistit, že funkce obdržela argument, na kterém je definovaná.

Poté už stačí jen spočítat výsledek a vrátit objekt typu \lstinline{Real}, reprezentující reálné
číslo v jazyce TIL-Script.

\begin{lstlisting}[caption={Konstruktor InvSqrt}, language=Java]
  @NotNull
  @Override
  public Construction apply(
    @NotNull InterpreterInterface interpreterInterface,
    @NotNull List<? extends Construction> args,
    @NotNull FnCallContext ctx) {

    final Construction arg = args.get(0);

    if (! (arg instanceof Real)) {
      return new Nil(
        ctx.getPosition(),
        new ArrayList<>(),
        "Argument of InvSqrt must not be symbolic"
      );
    }

    final double value = ((Real) arg).getValue();

    if (value <= 0.0) {
      return new Nil(
        ctx.getPosition(),
        new ArrayList<>(),
        "Argument of InvSqrt must be greater than zero"
      );
    }

    final double res = 1.0 / Math.sqrt(value);

    return new Real(res, ctx.getPosition(), new ArrayList<>());
  }
\end{lstlisting}

Metoda \lstinline{apply} přijímá tři argumenty. První argument -- objekt typu
\lstinline{InterpreterInterface} slouží ke komunikaci s překladačem jazyka TIL-Script -- v tomto
případě jej nevyužijeme. Druhý argument je seznam argumentů, které obdržela funkce
\lstinline{InvSqrt}. Posledním argumentem je kontext aplikace funkce. Kontext obsahuje pozici
ve zdrojovém kódu, kde k aplikaci funkce došlo. Kontext využíváme pro hlášení chyb -- můžeme
uživateli naší knihovny přesněji říct, kde aplikoval funkci na argumenty, na kterých není
definována.

Konstruktor třídy \lstinline{Nil} přijímá pozici ve zdrojovém kódu, kde tato hodnota vznikla,
seznam hlášení, který opět bude prázdný, a nakonec důvod, proč je výsledkem aplikace funkce hodnota
\lstinline{Nil}. Seznam hlášení by v jazyce Kotlin nebylo třeba explicitně uvádět, neboť by byl
vytvořen implicitním argumentem. Tento seznam slouží k hlášení chyb, které však nemůžou vzniknout
při implementaci funkce v jazyce Java.

Konstruktor třídy \lstinline{Real} přijímá reálné číslo, které daný objekt představuje, pozici
ve zdrojovém kódu, kde byl daný objekt zkonstruován, a (opět prázdný) seznam hlášení.

\subsection{Implementace registrátoru}

Dále musíme implementovat vlastní registrátor. Registrátor musí implementovat rozhraní
\lstinline{SymbolRegistrar}. Rozhraní definuje řadu abstraktních metod -- opět si je můžeme nechat
vygenerovat vývojovým prostředím. Tyto metody nám umožňují registrovat např. struktury, typové
aliasy (\lstinline{TypeDef}), apod. Zde uvedeme pouze definici metody \lstinline{getFunctions()},
jež slouží k registraci funkcí. Zbylé metody vrací pouze prázdný seznam
(\lstinline{java.util.ArrayList}) a neuvádíme je zde za účelem zkrácení zápisu.

Metoda \lstinline{getFunctions()} pouze vytvoří seznam obsahující instanci námi vytvořené funkce.

\begin{lstlisting}[caption={Java registrátor}, language=Java]
public class JavaMathRegistrar implements SymbolRegistrar {

  @NotNull
  @Override
  public List<FunctionInterface> getFunctions() {
    return Arrays.asList(
      new InvSqrt()
    );
  }

}
\end{lstlisting}

\subsection{Aplikace \lstinline{InvSqrt} v TIL-Script programu}

Po implementaci a sestavení naší Java knihovny již stačí pouze knihovnu importovat v TIL-Script
programu a funkci aplikovat.

\begin{lstlisting}[caption={Aplikace InvSqrt}, language=Haskell]
Import "class://org.fpeterek.tilscript.javamath.JavaMathRegistrar".

['Println ['InvSqrt '4.0]].
\end{lstlisting}

Následně program spustíme a ujistíme se, že program vypíše očekávanou hodnotu. První řádek výpisu
obsahuje spuštění překladače. Druhý řádek je již výstup programu.

\begin{lstlisting}[caption={Aplikace InvSqrt}, language=Bash]
$ ./bin/tilscript.sh examples/javasqrt.tils
0.5
\end{lstlisting}

\endinput
