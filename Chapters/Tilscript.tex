\chapter{TILScript}

Nyní konečně přišel čas představit TILScript. TILScript je interpretovaný funkcionální programovací
jazyk, do znatelné míry inspirovaný jazyky jako Haskell nebo Lisp. Syntax TILScriptu by měla co
nejvíce připomínat syntaktické prvky Transparentní intenzionální logiky, aby pouhá znalost TILu
stačila k okamžitému pochopení TILScriptu. Sémantika by poté měla být stejná.

Tato kapitola je rozdělena do tří sekcí. V první sekci jsou popsány důležité základní rysy
TILScriptu. Druhá sekce popisuje již existující prvky TILScriptu, a případně dokumentuje změny
oproti předchozím verzím TILScriptu. Poslední sekce se věnuje navrhovaným rozšířením jazyka
TILScript.

\section{Charakteristické rysy TILScriptu}

Tato sekce popisuje charakteristické rysy TILScriptu v takové podobě, jakou nabývá v této práci.
Pokud se v některém bodě TILScript neshoduje s TILem či předchozími verzemi TILScriptu, je rozdíl
náležitě popsán a vysvětlen.

\subsection{Lambda kalkul parciálních funkcí}

\subsubsection{Shora neomezená arita funkcí}

% TODO: Ozdrojovat currying asi? Idk, lambda kalkul

Narozdíl od lambda kalkulu ve své tradiční podobě, nebo například jazyka Haskell, v Transparentní
intezionální logice není arita funkce shora omezená. TILScript musí tento fakt reflektovat. Proto
tento jazyk umožňuje definici i aplikaci funkcí libovolné (samozřejmě nezáporné) arity. Také zde
neexistuje rozvíjení funkcí (anglicky \textit{currying}). Zatímco např. v Haskellu jsou funkce
arity dvě nebo vyšší automaticky rozvinuty na sérií několika unárních funkcí, jejichž oborem hodnot
jsou unární nebo nulární funkce, a jedné nulární funkce která vrací žádaný výsledek, v TILScriptu
není arita nijak omezená.

\subsubsection{Parciální funkce a respektování principu kompozicionality}

Jelikož v TIL můžou být funkce parciální, musí i TILScript počítat s parcialitou funkcí. Dále musí
TILScript respektovat princip kompozicionality, základní rys Transparentní intenzionální logiky.
Jedním z důsledků principu kompozicionality je, že konstrukce, jejíž přinejmenším jeden konstituent
je nevlastní, bude také nutně nevlastní. Reprezentaci stavu, kdy parciální funkce je aplikována
na argumenty, na kterých není definována, se věnuje podsekce \textit{Hodnota Nil} \ref{nil-value}
této kapitoly. 

%TODO: Ocitovat
Jedinou výjimkou je funkce \lstinline{IsNil}, jež vrací pravdivostní hodnotu \lstinline{True},
pokud je její jediný argument \lstinline{Nil}, v opačném případě je jejím výsledkem
\lstinline{False}. Tato speciální sémantika funkce \lstinline{IsNil}, ačkoliv porušuje princip
kompozicionality a vyžaduje aplikaci unární funkce na "nic," je zvolena jako doplněk k funkci
\lstinline{Improper/(o*_n)} definované v Průvodci čtenáře, a jako kompromis mezi dodržením
principů TIL a umožněním zpracování chyb.

\subsection{Okamžité vyhodnocování}

Ačkoliv je TILScript funkcionální jazyk, vyhodnocování výrazů probíhá okamžitě
(\textit{Eager evaluation}). Okamžité vyhodnocování je potřeba k zajištění respektování principu
kompozicionality. Pokud by vyhodnocování bylo líné, uživatel by mohl jako argument funkce uvést
$v$-nevlastní konstrukci, která by nikdy nebyla vyhodnocena, a došlo by tak k aplikaci funkce
na chybějící argument. Tato situace by mohla nastat například v případě aplikace funkce, jež 
některé své argumenty utilizuje pouze pokud je splněna určitá podmínka.

\subsection{Neměnnost proměnných a symbolů (\textit{Immutability})}

Jelikož je TILScript funkcionální jazyk, jsou hodnoty všech proměnných konstantní -- tedy
jakmile je proměnné jednou přiřazena valuace, nelze její hodnotu změnit. Dále nelze proměnnou
zastínit (angl. \textit{to shadow, shadowing}) v rámci oblasti platnosti (angl. \textit{scope}),
ve které byla definována. Proměnnou lze zastínit vytvořením nové oblasti platnosti (tedy například
na novém rámci zásobníku, angl. \textit{stack frame}).

Obdobně nelze redefinovat funkce nebo změnit typ symbolické hodnoty (viz \ref{symbolic-values}).

\subsection{Definice a deklarace symbolů}

TILScript nově rozlišuje mezi deklaracemi a definicemi proměnných a funkcí. Deklarace pouze
uvědomí překladač o existenci proměnné nebo funkce, nijak ale nedefinuje valuaci proměnné nebo
sémantiku funkce. Deklarace umožňuje funkci či proměnnou zmínit (např. v trivializaci, v uzávěru),
neumožňuje nám však proměnnou provést nebo funkci aplikovat -- jak také, když neznáme hodnotu
proměnné, případně sémantiku dané funkce. Provedení deklarované, avšak nedefinované proměnné
je chybou, při které interpreter ohlásí chybu a běh programu je ukončen. Deklarovat jeden symbol
lze vícekrát, deklarace však nesmí být konfliktní a lišit se typy.

\begin{lstlisting}[caption={Hlášení chyby při chybějící definici}]
$ java -jar interpreter/build/libs/tilscript.jar examples/undef-var.tils
** Error **
(4, 1): myVar.
    ~~~ ^ ~~~
        Variable 'myVar' is declared but undefined
$ java -jar interpreter/build/libs/tilscript.jar examples/undef-fn.tils
** Error **
(2, 1): MyFn/(Int Int Int).
    ~~~ ^ ~~~
        Function MyFn is declared but undefined, application is impossible
\end{lstlisting}

Definice přiřadí proměnné valuaci, funkci sémantiku. Proměnné s řádnou definicí lze provést
a můžou tak být konstituentem prováděné konstrukce. Funkce s řádnou definicí lze aplikovat. Funkce
i proměnné lze definovat pouze jednou. Opakovaná definice je chybou a vyústí v předčasné ukončení
programu.

Symbolické hodnoty, viz \ref{symbolic-values}, lze pouze deklarovat.

Deklarace jsou automaticky odvozeny z definic. Proto, pokud je známa definice, není třeba dodávat
také deklaraci. K interpretaci deklarací automaticky dochází před interpretací definic, aby byla
umožněna např. definice vzájemně rekurzivních funkcí. Definice jsou interpretovány v takovém
pořadí, v jakém jsou uvedené ve zdrojovém kódu.

Deklarace bez řádných definic na první pohled můžou působit zbytečně. K čemu může sloužit funkce,
kterou nelze aplikovat? Nesmíme však zapomenout, že konstrukce TIL samy vyjadřují význam, a nemusí
nutně sloužit k provedení. Provedením konstrukce sice dostaneme její denotát, ten nás ale ne vždy
zajímá. Představme si tedy případ, kdy provádíme analýzu výrazu přirozeného jazyka. Výraz
analyzujeme pomocí Transparentní intenzionální logiky a získáme konstrukci. S danou konstrukcí
chceme dále pracovat a chceme ji strojově zpracovat. Její denotát nás ovšem nezajímá, zajímá nás
pouze význam konstrukce. Současně daná konstrukce obsahuje funkci, jejíž definici neznáme, známe,
ale nejsme schopni ji strojově vyjádřit, nebo nás pouze nezajímá. Jelikož víme, že konstrukci
nebudeme provádět, a tedy nebudeme ani aplikovat funkci v ní zmíněnou, nepotřebujeme znát její
přesnou definici. Stačí nám znát pouze její název a typ.

Jako příklad nevyjádřitelné funkce lze uvést například všeobecný kvantifikátor. Ačkoliv všeobecný
kvantifikátor existuje jako funkce v Transparentní intenzionální logice, nelze jej korektně
definovat tak, aby byl vždy strojově vyhodnotitelný.

Názvosloví \textit{deklarace}, \textit{definice} je převzáno z programovacího jazyka C, kde
deklarace pouze uvědomí překladač o existenci symbolu, definice poté přiřadí symbolu konkrétní
hodnotu. Počet deklarací je shora neomezený, zato definice může existovat nanejvýš jedna. Deklarace
nedefinovaného symbolu není chybou, ovšem snaha nedefinovaný symbol využít (např. volání funkce,
přístup k proměnné) vyústí v chybu při procesu linkování.

\section{TILScript jako výpočetní varianta TILu}

Tato sekce popisuje základní výrazy a konstrukce TILScriptu, které existovaly již v předchozích
verzích jazyka. Pokud práce tyto výrazy nějakým způsobem upravuje, je úprava náležitě popsána
a zdůvodněna.

\subsection{Věty TILScriptu}

V TILScriptu za věty (\textit{sentence}) považuje výrazy na nejvyšší úrovni v programu. Větou je
tedy například konstrukce taková, že není podkonstrukcí jiného výrazu než sebe samotné, ale také
definice funkce, proměnné, typu, apod. Každá věta musí být ukončena terminátorem. Roli terminátoru
v TILScriptu zastává znak \lstinline{.} (ASCII tečka).

\subsection{Atomické datové typy}

Atomické datové typy v TILScriptu vycházejí z výchozí báze využívané v Transparentní intenzionální
logice k analýze přirozeného jazyka, tedy množinám ${o, \iota, \tau, \omega}$. TILScript ovšem
rozlišuje mezi časy a reálnými čísly, a pro tyto hodnoty definuje dva nekompatibilní typy, mezi
kterými neexistuje implicitní konverze. Dále TILScript využívá datový typ $\nu$ představující celá
čísla. Nakonec TILScript pro názvy typů nevyužívá řecká písmena, která nelze prakticky a jednoduše
zapisovat na spoustě rozložení klávesnic, ale anglická slova nebo zkratky. Názvy typů vždy začínají
velkým písmenem.

Typ $o$ představující pravdivostní hodnoty TILScript pojmenovává \lstinline{Bool} a může nabývat
hodnot \lstinline{True} a \lstinline{False}.

Typ $\iota$, v TILScriptu \lstinline{Indiv}, označujeme jako množinu individuí. Individua
v Transparentní intenzionální logice považujeme za "holá" -- žádnou netriviální vlastnost nemají
nutně. Všechny netriviální vlastnosti individuí jsou určeny stavem světa. Individuum samotné nemá
žádnou inherentní valuaci. Slouží pouze jako unikátní indentifikátor. Obdobně hodnoty
\lstinline{Indiv} v jazyce TILScript nemají žádnou konkrétní reprezentaci. Typ \lstinline{Indiv}
je využíván v konjunkci se symbolickými hodnotami, viz \ref{symbolic-values}. Tímto TILScript
umožňuje uživateli referovat na konkrétní individuum pouze pomocí symbolického identifikátoru,
aniž by individuím musely být přiřazeny arbitrárně zvolené konkrétní hodnoty.

Reálná čísla TILScript reprezentuje typem \lstinline{Real}. V implementaci překladače vytvořeném
v rámci této práce jsou reálná čísla interně reprezentována typem \lstinline{double}. TILScript
samotný žádné omezení na reprezentaci reálných čísel nestanovuje, prakticky však reálná čísla
v současné implementaci reprezentujeme pomocí 64bitové reprezentace dle IEEE 754.

Celá čísla TILScript reprezentuje typem \lstinline{Int}. Obdobně jako u typu \lstinline{Real}
neexistuje omezení pro reprezentaci celých čísel. Interně je využíván datový typ \lstinline{long},
jedná se tedy o 64bitové znaménkové číslo reprezentované dvojkovým doplňkem.

Množinu možných časů modelujeme typem \lstinline{Time}. Pro interní reprezentaci časových okamžiků
byl v této práci zvolen datový typ \lstinline{long}. Uživatel se sám může rozhodnout, jak bude tyto
hodnoty interpretovat. Ve standardní knihovně lze však nalézt např. funkci \lstinline{Now}, jejíž
aplikací získáme počet milisekund uplynulých od 1. ledna 1970.

Typ konstrukcí, v TIL denotován $*$, byl v TILScriptu přejmenován na \lstinline{Construction}.
V dřívějších verzích TILScriptu se pro typ konstrukcí také využíval znak $*$. Změna na
\lstinline{Construction} byla provedena z důvodu zachování konzistence s ostatními typy, které
v TILScriptu taktéž pojmenováváme anglickými slovy, a také z důvodu omezení ambiguity, aby se typ
konstrukce nepletl s funkcí násobení. Zatímco typograficky korektní reprezentací násobení je
využití znaku $\times$, na počítači násobení značíme $*$. Ačkoliv lze mezi funkcí násobení a
typem konstrukcí odlišit na základě kontextu, v jakém se znak objevuje, odlišení již v názvu
umožňuje uživateli jednoduše rozeznat typ konstrukce od násobení čísel okamžitě a bez bližšího
zkoumání kontextu.

Dále byl TILScript rozšířen o atomický typ sloužící k reprezentaci textu. Tento typ je podrobněji
popsán v sekci o rozšířeních TILScriptu, viz \ref{text-type}.

\subsection{Generický typ \textit{Any}}

V Transparentní intenzionální logice není neobvyklé definovat typově polymorfní funkce. Zvykem je
označovat předem neznámé typy řeckým písmenem $\alpha$. Obdobně TILScript umožňuje definici
typově polymorfních funkcí. Generické typy v TILScriptu značíme slovem \lstinline{Any}, okamžitě
následovaným indexem polymorfního typu. Index je libovolné číslo z rozsahu
$\bigl \langle 0; 2^{32}-1 \bigr \rangle$. Nenulové indexy nesmí začínat číslem 0.

Generické typy lze použít pouze v typech funkcí. Má-li více argumentů funkce stejný generický
typ, tedy typ \lstinline{Any} se stejným indexem, interpreter při procesu typové kontroly zajistí,
že argumenty, na něž je funkce za běhu aplikována, jsou stejného typu.

\subsection{Výrazy \textit{TypeDef}}

Výrazy \lstinline{TypeDef} umožňují přiřadit již existujícímu typu alternativní jméno.
\lstinline{TypeDef} nevytváří nový typ, jedná se pouze o alternativní název. V průběhu typové
kontroly jsou tyto jména rekurzivně přepisovány, dokud překladač nezjistí původní typ. Teprve poté
porovnává původní typy. Typové aliasy můžeme využívat například pro zkrácení zápisu komplikovaných
molekulárních typů. Obdobné zkratky v TIL využíváme běžně.

Korektní syntaktický zápis \lstinline{TypeDef} výrazu začíná právě klíčovým slovem
\lstinline{TypeDef}, následovaným novým názvem, operátorem přiřazení \lstinline{:=}, a nakonec
původním typem. Nový název musí začínat velkým písmenem.

\begin{lstlisting}[caption={Výraz TypeDef}]
TypeDef Float := Real.
TypeDef Property := (((Bool Indiv) Time) World).
\end{lstlisting}

\subsection{Funkce}

V matematice známe funkce jako jednoznačné zobrazení z množiny možných argumentů (definiční obor)
do množiny možných obrazů (obor hodnot). V programovacích jazycích konstrukce nazývané funkcemi
často nemusí být nejen jednoznačné (výstup nemusí odpovídat pouze argumentům), ale dokonce nemusí
být ani zobrazením (nevrací žádnou hodnotu, v takovém případě většinou modifikují stav světa,
jako příklad lze uvést funkce s návratovou hodnotou \lstinline{void} v jazyce C).

V jazyce TILScript, obdobně jako v TIL, jsou funkce vždy zobrazením do určitého oboru hodnot. Díky
parcialitě může být funkce degenerovaná, a v takovém případě nebude vracet hodnotu pro žádnou
kombinaci argumentů. V takovém případě se však jedná o určitou formu chybového stavu, spíše než
záměr, jak by tomu bylo v případě např. jazyka C. V čem se ovšem TILScript od Transparentní
intenzionální logiky liší, je možnost modifikovat stav světa. TILScript je funkcionální jazyk,
proto je na nejlepším uvážení uživatele, aby takovéto funkce nedefinoval, a jejich využívání omezil
na nutné minimum. Příkladem funkcí s vedlejšími efekty (tedy modifikujících stav světa) můžou
být například funkce \lstinline{Print}, \lstinline{Println} ze standardní knihovny, funkce
pro zápis do databáze, apod. Arita funkce musí být vždy alespoň jedna.

Pro zápis typu funkce využíváme podobnou notaci jako v Transparentní intenzionální logice.
Typy funkcí denotujeme kulatými závorkami. Uvnitř závorek uvedeme nejprve obor hodnot funkce,
poté uvádíme postupně typy argumentů. Jediný rozdíl oproti TIL spočívá v nutnosti zapsat mezeru
mezi názvy jednotlivých typů. Tedy ekvivalentem k typu $(o\nu\tau)$ by v TILScriptu byl typ
\lstinline{(Bool Int Real)}.

Funkce lze deklarovat uvedením názvu funkce následovaným lomítkem a jejím typem. Deklarujeme-li
více funkcí stejného typu, můžeme uvést více názvů oddělených čárkami. Pro definici funkce byla
přidána nová syntax popsaná v sekci \ref{fn-definition}.

\begin{lstlisting}[caption={Deklarace funkcí}]
Add, Sub, Mult, Div/(Int Int Int).
\end{lstlisting}

\subsection{Literály}

Názvosloví \textit{literál} je přejato z jiných programovacích jazyků. V TILScriptu literály
myslíme ne-funkce, tedy členy množin tvořícíh bázi. Literály lze uvádět celá i reálná čísla,
pravdivostní hodnoty, a také text (viz oddíl \ref{text-type} věnující se typu \lstinline{Text}).
Individua pomocí symbolických hodnot, viz Symbolické hodnoty \ref{symbolic-values}. Literály ovšem
nesmíme zapomenout trivializovat.

\subsection{Trivializace}

Trivializace v TILScriptu slouží ke stejnému účelu jako v Transparentní intezionální logice.
Narozdíl od TIL ovšem trivializaci denotujeme jednoduchým apostrofem namísto nuly zapsané jako
levý horní index.

\begin{lstlisting}[caption={Příklad trivializace.}]
'1          -- Trivializace konstanty typu Int
'3.14159    -- Trivializace konstanty typu Real
'['+ '1 '2] -- Trivializace kompozice
\end{lstlisting}

\subsection{Proměnné}

Proměnné v TILScriptu opět slouží stejném účelu jako proměnné v TIL, tedy $v$-konstruují hodnotu
v závislosti na valuaci $v$. Každé proměnné lze přiřadit hodnotu pouze jednou -- pro volné proměnné
při definici, pro $\lambda$-vázané proměnné při aplikaci funkce.

Volné proměnné lze deklarovat bez přiřazení valuace, ale také definovat a přiřadit jim konkrétní
hodnotu. Proměnné deklarujeme, pokud nás nezajímá konkrétní valuace. Přiřazení hodnoty využijeme
například v případě, kdy si chceme uložit výsledek drahé operace (např. čtení z databáze), nebo
si třeba jen chceme zkrátit zápis dlouhé konstrukce, a chceme pracovat s konkrétní valuací $v$.
Je-li konstrukce, jejíž hodnotu přiřazujeme proměnné, $v$-nevlastní, a tedy nekonstruuje žádnou
hodnotu, program skončí chybou. Vždy je třeba uvést typ hodnoty, kterou proměnná konstruuje.

Syntax pro deklaraci proměnné již existovala. Syntax pro definici proměnné (přiřazení hodnoty)
je nově zavedená. Deklarovat můžeme více proměnných najednou, za předpokladu, že se jedná o
proměnné stejného typu, stačí názvy jednotlivých proměnných oddělit čárkou. Přiřazujeme-li však
proměnné valuaci, můžeme uvést vždy pouze jednu proměnnou.

\begin{lstlisting}[caption={Příklad využití proměnných}]
x -> Int.               -- Deklarace proměnné v-konstruující hodnotu typu Int
y, z -> Int.            -- Deklarace více proměnných najednou
pi -> Real := '3.1415.  -- Definice proměnné pi aproximující hodnotu $\pi$
['* pi '2].             -- Využití proměnné pi jako konstituent konstrukce
long_varName123 -> Int.
\end{lstlisting}

Název proměnné musí začínat malým písmenem. 
\subsection{Provedení}

Provedení se sémantikou opět nijak neliší od svého ekvivalentu v Transparentní intenzionální logice.
Syntax ovšem musela být kvůli praktičnosti upravena, a proto bylo upuštěno od pravých horních
indexů. Provedení denotujeme \lstinline{^1}. Pro dvojí provedení poté využíváme \lstinline{^2}.
Dřívejší verze TILScriptu definovaly i trojí až deváté provedení. Protože však trojí a vícenásobné
provedení není v praxi skoro vůbec potřeba (dle Průvodce TIL taková potřeba nenastala), a protože
limit devátého provedení byl poněkud arbitrární (proč ne například desetinásobné provedení), je
tato práce konzervativní a drží se definice provedení z Průvodce.

Jelikož jsou všechny konstrukce standardně v módu provedení, není třeba provedení využívat příliš
často. Hlavně tedy budeme používat dvojí provedení.

\begin{lstlisting}[caption={Příklad využití provedení}]
^1 x.
^2['GetComposition argument1 argument2].
\end{lstlisting}

\subsection{Kompozice}

Kompozice umožňuje aplikovat funkce na argumenty. Kompozice využívají stejnou syntax jako v TIL.
Protože arita funkce musí být alespoň jedna, musí i kompozice obsahovat alespoň dvě podkonstrukce
-- funkci samotnou a alespoň jeden její argument. Počet argumentů, na něž funkci aplikujeme, musí
odpovídat počtu argumentů funkce. Dále nesmí být žádný argument nevlastní (s výjimkou funkcí
\lstinline{If} a \lstinline{IsNil}). V opačném případě k aplikaci funkce vůbec nedojde, neboť
nemáme argumenty, na které bychom funkci aplikovali, a kompozice je tak nevlastní.

\begin{lstlisting}[caption={Příklad využití kompozice}]
['* '2 '6].
\end{lstlisting}

\subsection{Uzávěry}

Sémantika uzávěrů je opět stejná jako v Transparentní intenzionální logice, syntax ovšem byla
upravena. Zatímco v TIL často vypouštíme hranaté závorky, v TILScriptu musíme závorky zapsat vždy.
Řecké písmeno lambda nahrazuje v TILScriptu znak zpětného lomítka.

Zpětné lomítko následuje seznam argumentů funkce konstruované uzávěrem. V dřívějších verzí
TILScriptu bylo možné typ argumentu v některých případech vynechat -- existovala-li volná proměnná
se stejným názvem jako $\lambda$-vázaná proměnná v uzávěru, a nebyl-li typ $\lambda$-vázané
proměnné uveden explicitně, byl typ $\lambda$-vázané proměnné automaticky dedukován podle typu
stejnojmenné volné proměnné. Tato práce však od této automatické dedukce upouští. Jelikož byly
do TILScriptu přidány výrazy \lstinline{import} umožňující importovat volné proměnné z jiného
souboru, uživatel TILScriptu by se mohl dostat do situace, kdy musí procházet několik importovaných
souborů, jen aby zjistil typ $\lambda$-vázané proměnné. V případě, kdy máme více $\lambda$-vázaných
proměnných, použijeme čárku pro jejich oddělení.

Za seznamem argumentů může nově následovat explicitní specifikace oboru hodnot konstruované funkce.
Specifikaci oboru hodnot denotujeme znaky \lstinline{->} které následuje název existujícího typu.
Explicitní specifikace je nepovinná, může však sloužit k zdůraznění úmyslu uživatele, aby čtenář
zdrojového kódu na první pohled znal typ funkce. Dále explicitní specifikace typu může pomoct při
typové kontrole.

Nakonec je třeba uvést konstrukci, nad kterou provádíme abstrakci.

\begin{lstlisting}[caption={Příklad využití uzávěrů}]
[\x: Int -> Int ['+ x '2]].
[\x: Int, y: Int -> Int ['+ x y]].
[\x: Int, y: Int ['+ x y]].

[[\x: Int, y: Int -> Int ['+ x y]] '2 '3].
\end{lstlisting}

\subsection{Zkrácený zápis typu intenzí a extenzionalizace}

V TIL často využíváme zkráceného zápisu jak pro typy intenzí, tak pro jejich extenzionalizaci.
Pro hodnoty typu $\alpha$ závislé na světamihu zkracujeme zápis $((\alpha\tau)\omega)$
na $(\alpha_{\tau\omega})$. Obdobně pro extenzionalizaci intenze $a$ využíváme zkráceného zápisu
$a_{wt}$ ekvivalentnímu konstrukci $[[a w] t]$, kde $a$ je konstrukce konstruující funkci
(většinou se jedná o trivializaci), a $w \rightarrow_v \omega$, $t \rightarrow_v \tau$. Jedná
se však pouze o notační zkratku -- o dohodu, ne součást TIL.

Ekvivalentní zkratky můžeme využívat také v TILScriptu. Chceme-li specifikovat typ intenze, můžeme
využít notační zkratku \lstinline{@tw}. Zkratku \lstinline{@wt} využijeme k extenzionalizaci
intenze. Zkratka \lstinline{@wt} vždy extenzionalizuje za využití proměnných \lstinline{w} a
\lstinline{t}. Proměnná \lstinline{w -> World} je součástí standardní knihovny, proměnnou
\lstinline{t -> Time} musí uživatel definovat sám. Zkrácenou notaci nelze využít s proměnnými
jiného názvu.

\begin{lstlisting}[caption={Příklad využití zkrácené notace}]
(Bool Indiv)@tw -- intenze typu (((Bool Indiv) Time) World)
['Rektor@wt 'VSB] -- extenzionalizace funkce Rektor/(((Indiv Indiv) Time) World)
                  -- a nasledna aplikace na argument VSB.
\end{lstlisting}

\subsection{Seznamy}

Seznamy se v Transparentní intenzionální logice příliš neobjevují. Při strojové analýze a
zpracování je však vhodné mít k dispozici způsob k vyjádření kolekce dat, proto TILScript seznamy
obsahuje. Seznam představuje homogenní seřazenou kolekci potenciálně neomezené délky. Seznamy můžou
obsahovat duplicity.

% TODO: Lisp ref
V této práci jsou všechny seznamy neměnné. Seznamy jsou definovány induktivně. Seznam (list) je buď
prázdný list, nebo \textit{cons cell} skládající se z hlavičky (známé jako head nebo CAR listu
z jiných jazyků) -- prvního prvku v seznamu, a z podseznamu reprezentujícího zbytek listu
(tail, CDR). Z definice tedy vyplývá, že vytvoření nového seznamu vložením prvku na začátek lze
provést v konstantním čase. Vytvoření nového seznamu přidáním prvku na konec jiného listu naopak
bude lineární vzhledem k velikosti původního kolekce. Tato implementace listu je volena zejména
proto, že umožňuje snadnou iteraci pomocí rekurzivních funkcí. Stejnou implementaci listů využíval
již jazyk LISP.

Typ seznamu denotujeme slovem \lstinline{List} následovaným kulatými závorkami, v nichž je uveden
typ prvku ukládaného v seznamu.

% TODO: Ref to stdlib documentation
Standardní knihovna obsahuje řadu funkcí pro práci s listy. Tyto funkce jsou v této kapitole pouze
nastíněny při ilustraci využití seznamů, podrobněji jsou však zdokumentovány v kapitole popisující
standardní knihovnu.

Dále interpreter implementuje syntaktický cukr pro jednodušší vytváření listů. Pro vytvoření
seznamu stačí v kompozici aplikovat funkci \lstinline{ListOf} na nenulový, avšak shora neomezený
počet argumentů. Během parsování bude tato kompozice korektně přepsána na sérii kompozic
využívajících funkci \lstinline{Cons} k vytvoření \textit{cons cells}. K žádné aplikaci funkce
na libovolný počet argumentů tedy nedochází. Při vytváření seznamu pomocí \lstinline{ListOf} musíme
dodat alespoň jeden prvek listu, aby bylo možné správně dedukovat typ prvků ukládaných v seznamu.
\lstinline{ListOf} je pouze syntaktický cukr překládaný při procesu parsování. Pokud bychom chtěli
generovat konstrukce konstruující listy dynamicky za běhu programu, museli bychom zřetězit aplikace
\lstinline{Cons}.

\begin{lstlisting}[caption={Příklad využití seznamů}]
['ListOf '1 '2 '3].                    -- vytvoreni listu
['Cons '1 ['Cons '2 ['ListOfOne '3]]]. -- ekvivalent predchoziho radku a priklad prepisu ListOf
['Head ['ListOf '1 '2 '3]]             -- 1
['Tail ['ListOf '1 '2 '3]]             -- ['ListOf '2 '3]
\end{lstlisting}

\subsection{N-tice}

N-tice doznály oproti předchozím verzím TILScriptu změny. Dříve byly n-tice homogenní kolekce
nespecifikované, avšak konečné délky. Roli homogenní kolekce však již zastává List, a v TILScriptu
neexistoval způsob, jak seskupit více hodnot jiného typu dohromady.

V matematice jsou n-tice například prvky kartézského součinu. N-tice lze definovat více způsoby,
vždy jsou však uspořádané, konečné a můžou být heterogenní (například provádíme-li kartézský součin
nad neidentickými množinami). Obdobnou roli plní n-tice i v TILScriptu. Délka n-tice je pevně daná,
stejně jako typy hodnot v n-tici. Celý typ n-tice je tedy dán uspořádaným výčtem všech typů všech
hodnot obsažených v této n-tici. Syntaktický zápis typu n-tice je podobný typu seznamu. Typ n-tice
denotujeme slovem \lstinline{Tuple}, následovaným kulatými závorkami. V závorkách ovšem uvádíme
výčet typů. Jednotlivé typy oddělujeme čárkami. Délka n-tice je určena počtem uvedených typů.

Práce s n-ticemi je do jisté míry podobná práci s listy. N-tici vytvoříme aplikací variadické
funkce \lstinline{MkTuple}. Stejně jako u funkce \lstinline{ListOf} se však jedná pouze o
syntaktický cukr. Funkce \lstinline{MkTuple} skutečně existuje, je to ale funkce binární, nikoliv
variadická, a vytváří dvojice z dodaných argumentů. Pokud ovšem funkci \lstinline{MkTuple} dodáme
více než dva argumenty, parser aplikaci \lstinline{MkTuple} rozepíše na jednu aplikaci
\lstinline{MkTuple} a následné řetězení funkce \lstinline{PrependToTuple}. Funkce pro práci
s n-ticemi jsou podrobněji popsány v uživatelské dokumentaci.
 
\begin{lstlisting}[caption={Příklad využití n-tic}]
['MkTuple '1 '2.0 'True].                    -- vytvoreni n-tice
['PrependToTuple '1 ['MkTuple '2.0 'True]].  -- ekvivalent predchoziho radku

x -> Tuple(Int, Real, Int) := ['MkTuple '1 '3.14159 '10].
\end{lstlisting}

\subsection{Symbolické hodnoty} \label{symbolic-values}

Název \textit{symbolické hodnoty} je v kontextu TILScriptu nový, jedná se však pouze o praktickou
implementaci entit, které již v TILScriptu existovaly. Entitu lze specifikovat uvedením jejího
názvu následovaného lomítkem a typem entity. Tímto byl názvu přiřazen typ, ale ne konkrétní
hodnota. Název \textit{symbolické hodnoty} je opět inspirován jazykem Lisp, kde podobný koncept
symbolů, tedy jmen bez hodnoty, již dlouhou dobu existuje.

Symbolické hodnoty využíváme, když potřebujeme o daném objektu referovat jménem, a ne hodnotou.
Jako příklad lze uvést například individua. Individua nemají žádnou inherentní hodnotu. Objekt
typu $\iota$ je pouze identifikátorem, unikátním jménem. Vlastnosti jsou individuím přiřazeny
intenzemi a závisí na čase a stavu světa, případně se jedná o triviální vlastnosti bez vypovídací
hodnoty. Dále můžeme zmínit například číslo $\pi$. Číslo $\pi$ sice bezpochyby hodnotu má, jedná
se o reálné číslo. Jelikož je však $\pi$ číslo iracionální, tedy číslo s nekonečným desetinným
rozvojem, bohužel jej nemůžeme reprezentovat v počítači. V praktické implementaci se tak musíme
spokojit pouze s aproximací čísla $\pi$, nebo právě se symbolickou reprezentací.

Symbolické hodnoty nelze provést. Chceme-li je zmínit, musíme využít trivializaci. Dále nad nimi
nelze provádět všechny operace, které jdou provádět s nesymbolickými konkrétními hodnotami.
Například jak bychom mohli příčíst k jinému číslu číslo $\pi$, když neznáme přesnou hodnotu čísla
$\pi$? Kde to však dává smysl, můžeme naprogramovat dodatečnou podporu pro symbolické hodnoty.
Funkce \lstinline{Sin}, \lstinline{Cos} v matematické knihovně mají zabudovanou kontrolu, zda
zda obdržely jako svůj argument symbol \lstinline{Pi/Real}. Pokud ano, funkce vrátí korektní
hodnotu. Obdobně by například výsledkem přirozeného logaritmu mohlo být číslo 1 při aplikaci
na symbol \lstinline{E/Real}.

\begin{lstlisting}[caption={Příklad využití symbolických hodnot}]
Pi/Real.
['Sin 'Pi]. -- 0
['Cos 'Pi]. -- -1
['+ '1 'Pi]. -- Nil - vysledek existuje, na pocitaci jej vsak nelze spocitat
\end{lstlisting}

\section{Rozšíření TILScriptu}

Tento oddíl nastiňuje nadstandardní rozšíření TILScriptu. Cílem těchto rozšíření je udělat
z TILScriptu nástroj pro analýzu a práci s konstrukcemi Transparentní intenzionální logiky. Každá
změna a rozšíření je zdůvodněna.

\subsection{Komentáře}

Komentáře v TILScriptu plní stejnou roli jako v jiných programovacích jazycích. Jedná se tedy
o text, který je interpreterem ignorován. Komentáře tak můžeme využít například k popisu kódu.
Komentáře existují pouze v jednořádkové podobě a denotujeme je, podobně jako v Haskellu nebo SQL,
dvěma pomlčkami (\lstinline{--}). Všechny znaky za pomlčkami až po první znak odřádkování jsou
překladačem automaticky ignorovány.

\begin{lstlisting}[caption={Příklad využití komentářů}]
-- The following construction computes the cosine of pi and prints the result
['Print ['Cos 'Pi]]. -- Prints -1
\end{lstlisting}

\subsection{Definice pojmenovaných funkcí} \label{fn-definition}

Syntax TILScriptu byla rozšířena o možnost definice pojmenovaných funkcí. Jedná se o způsob, jak
funkci přiřadit jméno a následně na danou funkci odkazovat jménem, namísto uvádění stejného uzávěru
vícekrát ve zdrojovém kódu. Definice pojmenovaných funkcí byla v TILScriptu již několikrát přidána
a vždy byla zase odstraněna. Dokud TILScript sloužil pouze jako notace pro zápis TIL konstrukcí,
byl přínos této funkcionality diskutabilní. Pokud však chceme experimentovat s možnostmi využití
TILScriptu také jako nástroje pro analýzu TIL konstrukcí, definice pojmenovaných funkcí je
nezbytná.

Definici funkce denotujeme klíčovým slovem \lstinline{Defn}. Následuje hlavička funkce, symbol
přiřazení (\lstinline{:=}), a nakonec konstrukce předepisující sémantiku funkce. Syntax je odlišná
od notace pro zápis uzávěrů. Důvodem pro tento rozdíl je grafické odlišení hlavičky funkce
specifikující název, argumenty a typ výsledku od těla funkce (konstrukce). Dále tato notace
omezuje počet vnořených závorek a speciálních znaků v tělu funkce. Vazba argumentů funkce je
samozřejmě ekvivalentní $\lambda$-vázaným proměnným.

Název funkce musí začínat velkým písmenem. Dále může obsahovat malá i velká písmena, čísla
a podtržítka. Povolena jsou všechna písmena české abecedy (tedy například české \textit{č} je
povoleno, avšak katalánské \textit{\c{c}} povoleno není).

\begin{lstlisting}[caption={Příklad definice funkcí}]
-- Binary function
Defn Add(x: Int, y: Int) -> Int := ['+ x y].

-- Example of a recursive function
Defn Sum(list: List(Int)) -> Int :=
    ['If
        ['IsEmpty list] '0
        'True ['+ ['Head list] ['Sum ['Tail list]]]].
\end{lstlisting}

\subsection{Typ \textit{Text}} \label{text-type}

Typ \lstinline{Text} slouží k reprezentaci textu. Opět se jedná o typ, který není příliš potřeba
pro analýzu přirozeného jazyka, neboť v přirozené řeči často vypovídáme o individuích, málokdy však
o samotných korpusech textu. V programovacím jazyku je však forma reprezentace textu nezbytná.
Typ \lstinline{Text} využíváme jak k reprezentaci delších textů, tak k reprezentaci jednotlivých
znaků. TILScript tedy nezná koncept typu pro samostatné znaky (jako např. \lstinline{Char} v jazyce
Haskell), a \lstinline{Text} není \lstinline{List} znaků. Jedná se o atomický typ. Pomocí funkcí
standardní knihovny však lze z textů extrahovat podřetězce (včetně jednotlivých znaků),
konkatenovat řetězce, apod.

Literály typu \lstinline{Text} uvozujeme dvojitými uvozovkami. Hodnoty typu text musíme
trivializovat. V literálech textů můžeme používat escape sekvence. Texty podporují standard
Unicode. Interně jsou reprezentovány objekty \lstinline{java.lang.String} a tudíž využívají
kódování UTF-16 a jsou internovány.

\begin{lstlisting}[caption={Příklad využití typu Text}]
text -> Text := '"Můj text".
text2 -> Text := '"Text na\ndva řádky".
['Println '"Výpis textu"].
\end{lstlisting}

\subsection{Výrazy \textit{Import}}

Výrazy \lstinline{Import} umožňují importovat symboly definované v jiném souboru nebo Java archivu
(\textit{.jar} souboru). Výrazy \lstinline{Import} jsou vždy interpretovány jako první při
interpretaci souboru. Každý soubor můžeme importovat nanejvýš jednou v rámci jednoho souboru.
Obsahuje-li soubor se zdrojovým kódem TILScriptu více importů stejné závislosti, je daná závislost
importována pouze jednou, následující importy jsou ignorovány.

Každý soubor interpretován pouze jednou. Pokud tedy více souborů importuje jeden soubor, daný
soubor bude interpretován pouze při první importu. Při první interpretaci si překladač uloží
všechny symboly definované v daném souboru (symbolické hodnoty, funkce, proměnné). Při následných
importech stejného souboru jsou poté pouze importovány tyto symboly. Tedy hodnoty proměnných jsou
spočítány pouze jednou, poté dané zůstává stále stejná proměnná. Obsahuje-li importovaný skript
konstrukce na nejvyšší úrovni v programu (tedy takové, že nejsou podkonstrukcí jiné konstrukce než
sebe samotné), jsou dané konstrukce provedeny pouze při prvním importu programu. Při importu
skriptu je nejprve interpretován celý skript, teprve poté jsou symboly definované v daném souboru
importovány do kontextu skriptu, který na daném tomto souboru závisí.

Pro import souboru uvedeme nejprve klíčové slovo \lstinline{Import}, následované cestou
k požadovanému souboru. Cesta může být absolutní nebo relativní k umístění aktuálně překládaného
souboru. Cesta musí být uvozena uvozovkami. Importy se můžou nacházet pouze na nejvyšší úrovni
v programu, neboť se jedná o metavýrazy, ne konstrukce.

Symboly můžeme importovat také z Java archivu. V takovém případě musí být daný Java archiv načten
již při spouštění překladače společně s kódem překladače. Načítání \textit{.jar} souborů za běhu
je z bezpečnostních důvodů velmi komplikované. Dále musí daný Java archiv obsahovat tzv.
\textit{registrátor} symbolů konformující vůči předdefinovanému rozhraní. Pro import souborů
za využití registrátoru stačí místo cesty k TILScript souboru uvést celý plně kvalifikovaný název
třídy registrátoru s předponou \textit{class://}. Právě tato přepona značí, že se jedná o import
z \textit{.jar} souboru. Překladač poté vytvoří instanci určeného registrátoru a naimportuje
soubory definované tímto registrátorem. Rozhraní registrátorů je popsáno v uživatelské dokumentaci.

Importy nejsou tranzitivní. Tedy importujeme-li soubor, který sám importuje jiné soubory, budou
importovány pouze symboly definované v daném souboru, ne však symboly definované v jeho
závislostech. Importy nesmí obsahovat konfliktní definice.

\begin{lstlisting}[caption={Příklad využití výrazů Import}]
Import "dependency.tils".
Import "relative/path.tils".
Import "class://org.fpeterek.tilscript.math.Registrar".
\end{lstlisting}

\subsection{Typ \textit{Type}}

Typ \lstinline{Type} slouží k reprezentaci typů a je primárně metaprogramovacím prvkem. V tradiční
Transparentní intenzionální logice o typech vypovídat nemůžeme. Typově polymorfní TIL není
momentálně předmětem výzkumu. Pro účely metaprogramování je však možnost reprezentace typů
nezbytná. Typ \lstinline{Type} umožňuje pracovat s typy jako s validními hodnotami jazyka
TILScript. Typové reference, tedy hodnoty typu \lstinline{Type}, využijeme například k implementaci
statické typové kontroly (překladač TILScriptu provádí typovou kontrolu pouze za běhu),
ke generování validních TILScript programů, apod.

Pokud by TILScript typ \lstinline{Text} neobsahoval, musel by být za účelem analýzy TILScriptu
implementován parser TILScriptu v TILScriptu, nebo by uživatelé museli využívat jiné programovací
jazyky. Proto tato práce navrhuje rozšíření TILScriptu o metaprogramovací prvky za účelem unifikace
a zjednodušení nástrojů pro práci s Transparentní intenzionální logikou.

S typovými referencemi pracujeme obdobně jako s objekty z bázových množin. Zodpovědností uživatele
však je, aby typové reference využíval opatrně a vyhýbal se jim, bude-li TILScript používat pouze
pro interpretaci TIL konstrukcí.

\begin{lstlisting}[caption={Příklad využití typových referencí}]
intType -> Type := Type.
typeOf5 -> Type := ['TypeOf '5].
\end{lstlisting}

\subsection{Typ \textit{DeviceState}}

Typ \lstinline{DeviceState} využíváme k označení funkcí závisejících na stavu zařízení, na němž
běží překladač. Standardní knihovna definuje proměnnou \lstinline{deviceState -> DeviceState},
kterou uživatel může využívat kdekoliv, kde je hodnota typu \lstinline{DeviceState} vyžadována.
Hodnoty typu \lstinline{DeviceState} nemají žádnou inherentní hodnotu, obdobně jako objekty typu
\lstinline{World}. Jako příklad funkcí závislých na stavu zařízení lze uvést například funkci
\lstinline{Now} vracející aktuální čas, nebo funkci \lstinline{Random}, jejíž výsledkem je náhodné
číslo (v aktuální implementaci číslo pseudonáhodné, nic však nebrání využití např. hardwarových
generátorů náhodných čísel nebo \lstinline{/dev/random}, pokud je to na dané platformě možné).

\begin{lstlisting}[caption={Příklad funkcí závislých na stavu zařízení}]
['Now deviceState].
['Random deviceState].
RandFromDevRandom/(Int DeviceState).
\end{lstlisting}

\subsection{Hodnota \textit{Nil}} \label{nil-value}

Hodnota \lstinline{Nil} slouží k reprezentaci chybového stavu, kdy konstrukce nekonstruuje žádnou
hodnotu. Je-li jedním z argumentů funkce \lstinline{Nil}, je výsledek automaticky znovu
\lstinline{Nil}. Pro vyvolání chybového stavu je možné \lstinline{Nil} zmínit přímo v TILScript
konstrukci. Trivializace \lstinline{Nil} však není povolená gramatikou, neboť trivializace nemůžou
být nevlastní.

Specifikem implementace je, že hodnota \lstinline{Nil} obsahuje metadata popisující kde a proč
došlo k selhání a konstrukce nezkonstruovala žádnou hodnotu. Pokud konstrukce na nejvyšší úrovni
v programu nezkonstruuje hodnotu a výsledkem jejího provedení je \lstinline{Nil}, program skončí
neúspěchem a uživateli je nahlášena chyba.

\begin{lstlisting}[caption={Příklad využití Nil}]
['If
    ['= a '0] Nil
    ['= b '0] Nil
    'True ['* ['/ ['Log a] b]]].
\end{lstlisting}

\begin{lstlisting}[caption={Příklad hlášení chyby}]
(1, 17): ['* ['+ '1 '2] ['/ '6 '0]].
                     ~~~ ^ ~~~
         Division by zero
** Error **
(1, 17): ['* ['+ '1 '2] ['/ '6 '0]].
                     ~~~ ^ ~~~
         Nil constructed by a top level construction. Aborting execution.
\end{lstlisting}

\subsection{Struktury} \label{structs}

Struktury, obdobně jako n-tice, umožňují shlukovat více hodnot různorodých typů. Narozdíl od n-tic,
jejichž členy indexujeme číselně, atributy struktur jsou pojmenované a přistupujeme k nim jménem.
Dále můžou být struktury definovány rekurzivně. Tato charakteristika umožňuje například
reprezentovat grafy. Atributu struktury nemůže být přiřazena hodnota \lstinline{Nil}.

Během typové kontroly jsou porovnávany nejen typy atributů struktur, ale také názvy porovnávaných
struktur. Liší-li se struktury názvem, ačkoliv jsou ve všech ostatních ohledech stejné, jsou
považovány za rozdílné typy. Struktury nám tedy, narozdíl od n-tic, umožňují lépe využívat typového
systému TIL.

\subsubsection{Definice struktur}

Strukturu definujeme klíčovým slovem \lstinline{Struct}. Dále uvedeme jméno struktury, a do
složených závorek seznam atributů. Nejprve vždy uvedeme název atributu, za dvojtečku pak jeho typ.
Jednotlivé atributy oddělujeme čárkami. Název struktury musí být validním názvem typu -- musí
začínat velkým písmenem. Při pojmenovávání atributů se pak řídíme pravidly pro jména proměnných
a začínáme vždy malým písmenem. Za posledním atributem může ale nemusí být čárka -- tzv.
\textit{trailing comma}.

\begin{lstlisting}[caption={Příklad definice struktury}]
Struct Tree {
    value: Int,
    subtrees: List(Tree),
}.
\end{lstlisting}

\subsubsection{Konstruktory struktur}

Konstruktory struktur umožňují vytvářet objekty uživatelem definovaného typu -- struktury.
Pro konstruktory byla vytvořena nová syntax. Do složených závorek uvedeme nejprve název struktury,
následně pak uvádíme konstrukce, které budou provedeny jako konstituenty konstruktoru. Výsledky
provedení poté budou přiřazeny jednotlivým atributům struktury. Argumenty konstruktoru musíme uvést
v pořadí odpovídající definici struktury. Konstruktory nevyužívají typové reference, název
konstruovaného typu tedy netrivializujeme, jedná se pouze o syntaktický prvek. Jinak jsou
konstruktory ekvivalentní kompozicím -- pokud konstruktor neobdrží alespoň jeden z požadovaných
argumentů, je konstruktor $v$-nevlastní, jinak konstruktor konstruuje hodnotu specifikovaného typu.

Konstruktory můžeme využít také ke konstrukci prázdných listů. Konstrukce listů pomocí
\lstinline{ListOf} využívá typovou inferenci pro určení typu seznamu. Prázdný list však pomocí
kompozice nelze vytvořit. Dále využití konstruktorů pro konstrukci prázdných seznamů umožňuje
vyhnout se využívání typových referencí. Neprázdný list pomocí konstruktoru vytvořit nelze.

\begin{lstlisting}[caption={Příklad definice struktury}]
{List(Tree)}. -- Konstrukce prazdneho listu
{Tree '0 {List(Tree) }}. -- Konstrukce objektu typu Tree

myTree -> Tree := {Tree
    '1
    ['ListOf 
        {Tree '2 {List(Tree) }}
        {Tree '3 ['ListOf {Tree '4 {List(Tree) } }]}]}.
\end{lstlisting}

\subsubsection{Přístup k atributům}

Za účelem přístupu k atributům byl přidán syntaktický konstrukt \lstinline{::}. Za název objektu,
k jehož atributu přistupujeme, zapíšeme \lstinline{::} následované názvem požadovaného atributu.
Přístupy k atributům lze řetězit, potřebujeme-li přistoupit k atributu atributu. Přístup k atributu
má vyšší prioritu než trivializace -- tedy trivializací trivializujeme celý přístup k atributu,
nepřistupujeme k atributu trivializace.

Reálně je však atribut pouze proměnná, ačkoliv se jedná o proměnnou ve strukturovaném shluku.
Proto i sémantika provedení atributu je stejná jako sémantika provedení proměnné. Přístup
k neexistujícímu atributu je chybou. Provedení existujícího atributu (proměnné) vždy zkonstruuje
hodnotu, neboť atributy nemůžou být nevlastní.

\begin{lstlisting}[caption={Příklad přístupu k atributům objektu}]
tree::subtrees.
['Println struct::nested::attributes].
\end{lstlisting}

\endinput
